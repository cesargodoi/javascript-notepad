{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Resolvi fazer esta documenta\u00e7\u00e3o para ir registrando o meu aprendizado de <code>JavaScript</code>.</p>"},{"location":"basico/js-html/","title":"Html + JavaScript","text":"<p>Lincamos a nossa p\u00e1gina <code>index.html</code> com o nosso script <code>main.js</code>, atrav\u00e9s do atributo <code>src</code> da tag <code>script</code>:</p> index.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;With HTML&lt;/title&gt;\n  &lt;/head&gt;\n\n  &lt;body&gt;\n    &lt;script src=\"./main.js\"&gt;&lt;/script&gt; &lt;!- aqui n\u00f3s fazemos a jun\u00e7\u00e3o -&gt;\n  &lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre> main.js<pre><code>/**\n * Tudo o que for colocado dentro do 'main.js' \n * ser\u00e1 aplicado no arquivo 'index.html'.\n*/\n\nalert('Os arquivos est\u00e3o lincados!');  // ser\u00e1 mostrada em uma caixa de mensagem\n\nconsole.log('J\u00e1 essa mensagen, aparecer\u00e1 no console do navegador');\n</code></pre>"},{"location":"basico/numbers/","title":"N\u00fameros","text":"<p>Os principais tipos de n\u00fameros em JavaScript s\u00e3o:</p> <p>N\u00fameros inteiros (Integers): Representam n\u00fameros inteiros, positivos ou negativos, sem casas decimais. Exemplos: 42, -10, 0.</p> <p>N\u00fameros de ponto flutuante (Floating-Point Numbers): S\u00e3o usados para representar n\u00fameros com casas decimais. JavaScript usa o padr\u00e3o IEEE 754 para representar n\u00fameros de ponto flutuante de precis\u00e3o dupla. Exemplos: 3.14, -0.5, 1.0.</p> <pre><code>// Alguns exemplos\nlet num1 = 1;\nlet num2 = 2.5;\n\nconsole.log(num1 + num2);  // 3.5\n\n// .toString()\nconsole.log(num1.toString() + num2);  // 12.5 (sting)\n\nlet num3 = 123;\nconsole.log(num3.toString(2));   // 1111011 (bin\u00e1rio)\nconsole.log(num3.toString(8));   // 173 (octal)\nconsole.log(num3.toString(16));  // 7b (hexadecimal)\n\n// .toFixed()\nlet num4 = 23.3566352435\nconsole.log(num4.toFixed(2));  // 23.36\n\n// Number.isIntteger()\nconsole.log(Number.isInteger(num1));  // true\nconsole.log(Number.isInteger(num2));  // false\n\n// Number.isNaN()\nlet temp1 = num2 * 'X';\nlet temp2 = num2 * '10';\nconsole.log(Number.isNaN(temp1));  // true\nconsole.log(Number.isNaN(temp2));  // false\n</code></pre> <p>O javascript usa IEEE 754-2008 para gerenciar os seu c\u00e1lculos.</p> <pre><code>// imprecis\u00f5es\nlet n1 = 0.7;\nlet n2 = 0.1;\n\nconsole.log(n1 + n2);  // 0.7999999999999999 \ud83e\udd14\n\nconsole.log(100 / 0);  // Infinity \ud83e\udd14\n</code></pre>"},{"location":"basico/objects/","title":"Objetos","text":"<p><code>Objects</code>  s\u00e3o estruturas de dados que pode armazenar valores e fun\u00e7\u00f5es  relacionados. Os objetos s\u00e3o uma parte fundamental da linguagem e s\u00e3o usados  para representar e organizar informa\u00e7\u00f5es de maneira eficaz. Eles s\u00e3o  constru\u00eddos a partir de pares de chave-valor, nos quais as chaves s\u00e3o <code>strings</code>  (ou <code>symbols</code>) que atuam como identificadores e os valores podem ser de  qualquer tipo de dado, incluindo <code>numbers</code>, <code>strings</code>, outros <code>objects</code>,  <code>functions</code> e assim por diante.</p> <p>Vejamos um exemplo de objeto: <pre><code>var pessoa = {\n  nome: \"Jo\u00e3o\",\n  idade: 30,\n  profissao: \"Desenvolvedor\"\n};\n</code></pre></p> <p>Neste exemplo, <code>pessoa</code> \u00e9 um objeto com tr\u00eas propriedades: <code>nome</code>, <code>idade</code> e  <code>profissao</code>, e cada propriedade tem um valor associado a ela.</p> <p>Voc\u00ea pode acessar as propriedades de um objeto usando a nota\u00e7\u00e3o de ponto ou a  nota\u00e7\u00e3o de colchetes, assim:</p> <pre><code>console.log(pessoa.nome);      // Jo\u00e3o\nconsole.log(pessoa['idade']);  // 30\n</code></pre> <p>Al\u00e9m disso, voc\u00ea pode adicionar novas propriedades, modificar propriedades  existentes e at\u00e9 mesmo remover propriedades de objetos em JavaScript. Objetos  tamb\u00e9m podem conter <code>methods</code>, que s\u00e3o <code>functions</code> associadas a eles. Eles s\u00e3o  muito vers\u00e1teis e formam a base da programa\u00e7\u00e3o orientada a objetos em  JavaScript.</p>"},{"location":"basico/operators/","title":"Operadores","text":"<p>Em javascript n\u00f3s temos operadores aritim\u00e9ticos, de incremento e de atribui\u00e7\u00e3o</p>"},{"location":"basico/operators/#aritimeticos","title":"Aritim\u00e9ticos","text":"<p>adi\u00e7\u00e3o / concatena\u00e7\u00e3o (+) <pre><code>console.log(2 + 3);      // 5\nconsole.log('b' + 'a');  // ba\nconsole.log('a' + 15);   // a15\n</code></pre></p> <p>subtra\u00e7\u00e3o (-) <pre><code>console.log(10 - 3);     // 7\n</code></pre></p> <p>multiplica\u00e7\u00e3o (*) <pre><code>console.log(5 * 5);      // 25\n</code></pre></p> <p>divis\u00e3o (/) <pre><code>console.log(15 / 3);     // 5\n</code></pre></p> <p>potencia\u00e7\u00e3o (**) <pre><code>console.log(2 ** 3);     // 8\n</code></pre></p> <p>m\u00f3dulo da divis\u00e3o (%) <pre><code>console.log(18 / 5)      // 3\n</code></pre></p> <p>A preced\u00eancia de operadores \u00e9 a seguinte:</p> 1. (\u2026) o que estiver dentro dos parentesis 2. ** o que for potencia\u00e7\u00e3o 3. *   /   % multiplica\u00e7\u00e3o, divis\u00e3o e m\u00f3dulo da divis\u00e3o 4. +   - adi\u00e7\u00e3o e subtra\u00e7\u00e3o"},{"location":"basico/operators/#incremento","title":"Incremento (++)","text":"<p>Cada vez que \u00e9 usado, incrementa (ou decrementa) 1 do valor da vari\u00e1vel pode ser usado antes ou depois da vari\u00e1vel.</p> <pre><code>let num = 1;\nconsole.log(num++);  // imprime 1 e atualiza o valor de num para 2\nconsole.log(num);    // 2\nconsole.log(++num);  // atualiza o valor de num para 3 e imprime 3\nconsole.log(num);    // 3\n</code></pre>"},{"location":"basico/operators/#decremento-","title":"Decremento (- -)","text":"<pre><code>console.log(num--);  // imprime 3 e atualiza o valor de num para 2\nconsole.log(num);    // 2\nconsole.log(--num);  // atualiza o valor de num para 1 e imprime 1\nconsole.log(num);    // 1\n</code></pre>"},{"location":"basico/operators/#atribuicao","title":"Atribui\u00e7\u00e3o","text":"<pre><code>// += \nconsole.log(num += 10); // num = num + 10 -&gt; 11\n// -=\nconsole.log(num -= 2);  // num = num -  2 -&gt;  9\n// *=\nconsole.log(num *= 2);  // num = num *  2 -&gt; 18\n// /=\nconsole.log(num /= 3);  // num = num /  3 -&gt;  6\n// **=\nconsole.log(num **= 2); // num = num ** 2 -&gt; 36\n</code></pre>"},{"location":"basico/operators/#comparacao","title":"Compara\u00e7\u00e3o","text":""},{"location":"basico/operators/#maior-que","title":"maior que ( &gt; )","text":"<pre><code>console.log(10 &gt; 5);   // true\nconsole.log(10 &gt; 10);  // false\nconsole.log(10 &gt; 11);  // false\n</code></pre>"},{"location":"basico/operators/#maior-igual-a","title":"maior igual a ( &gt;= )","text":"<pre><code>console.log(10 &gt;= 5);   // true\nconsole.log(10 &gt;= 10);  // true\nconsole.log(10 &gt;= 11);  // false\n</code></pre>"},{"location":"basico/operators/#menor-que","title":"menor que ( &lt; )","text":"<pre><code>console.log(10 &lt; 5);   // false\nconsole.log(10 &lt; 10);  // false\nconsole.log(10 &lt; 11);  // true\n</code></pre>"},{"location":"basico/operators/#menor-igual-a","title":"menor igual a ( &lt;= )","text":"<pre><code>console.log(10 &lt;= 5);   // false\nconsole.log(10 &lt;= 10);  // true\nconsole.log(10 &lt;= 11);  // true\n</code></pre>"},{"location":"basico/operators/#igual-a","title":"igual a ( == )","text":"<p>checa ap\u00e9nas o valor (evitar o uso)</p> <pre><code>console.log(10 == 5);     // false\nconsole.log(10 == 10);    // true\nconsole.log(10 == '10');  // true (por coer\u00e7\u00e3o de tipos)\n</code></pre>"},{"location":"basico/operators/#diferente-de","title":"diferente de ( != )","text":"<p>checa ap\u00e9nas o valor (evitar o uso)</p> <pre><code>console.log(10 != 5);     // true\nconsole.log(10 != 10);    // false\nconsole.log(10 != '10');  // false (por coer\u00e7\u00e3o de tipos)\n</code></pre>"},{"location":"basico/operators/#estritamente-igual-a","title":"estritamente igual a ( === )","text":"<p>checa valor e tipo</p> <pre><code>console.log(10 === 5);     // false\nconsole.log(10 === 10);    // true\nconsole.log(10 === '10');  // false\n</code></pre>"},{"location":"basico/operators/#estritamente-diferente-de","title":"estritamente diferente de ( !== )","text":"<p>checa valor e tipo</p> <pre><code>console.log(10 !== 5);     // true\nconsole.log(10 !== 10);    // false\nconsole.log(10 !== '10');  // true\n</code></pre>"},{"location":"basico/operators/#logicos","title":"L\u00f3gicos","text":""},{"location":"basico/operators/#and","title":"And ( &amp;&amp; )","text":"<pre><code>console.log(true &amp;&amp; true);    // true\nconsole.log(true &amp;&amp; false);   // false\nconsole.log(false &amp;&amp; true);   // false\nconsole.log(false &amp;&amp; false);  // false\n</code></pre>"},{"location":"basico/operators/#or","title":"Or ( || )","text":"<pre><code>console.log(true || true);    // true\nconsole.log(true || false);   // true\nconsole.log(false || true);   // treu\nconsole.log(false || false);  // false\n</code></pre>"},{"location":"basico/operators/#not","title":"Not ( ! )","text":"<pre><code>console.log(!true);           // false\nconsole.log(!false);          // true\n</code></pre>"},{"location":"basico/short-circuit/","title":"Short Circuit (curto circuito)","text":"<p>Um \"short circuit\" refere-se a uma t\u00e9cnica de avalia\u00e7\u00e3o de express\u00f5es l\u00f3gicas  que pode ser usada para determinar rapidamente o resultado de uma express\u00e3o com  base na primeira parte avaliada. Isso \u00e9 particularmente \u00fatil em express\u00f5es  l\u00f3gicas compostas, como aquelas envolvendo operadores l\u00f3gicos <code>&amp;&amp;</code> (E l\u00f3gico) e  <code>||</code> (OU l\u00f3gico).</p> <p>Existem dois tipos principais de \"short circuit\" em JavaScript:</p>"},{"location":"basico/short-circuit/#operador-and","title":"Operador And ( &amp;&amp; )","text":"<p>Quando voc\u00ea usa o operador <code>&amp;&amp;</code>, a express\u00e3o \u00e9 avaliada da esquerda para  a direita. Se a primeira parte (\u00e0 esquerda) da express\u00e3o for avaliada como  falsa, a segunda parte (\u00e0 direita) n\u00e3o ser\u00e1 avaliada, economizando recursos.  Isso \u00e9 \u00fatil para express\u00f5es em que todas as partes precisam ser verdadeiras  para que a express\u00e3o seja verdadeira.</p> <p>Exemplo: <pre><code>function sayHello(name) {\n    return `Hello ${name}`;\n}\n\nlet toPrint = '';\nconsole.log(toPrint &amp;&amp; sayHello('Ot\u00e1vio'));  // \n\ntoPrint = 'a';\nconsole.log(toPrint &amp;&amp; sayHello('Sergio'));  //  Sergio\n</code></pre></p>"},{"location":"basico/short-circuit/#operador-or","title":"Operador Or ( || )","text":"<p>Com o operador <code>||</code>, a express\u00e3o \u00e9 novamente avaliada da esquerda para a  direita. No entanto, se a primeira parte (\u00e0 esquerda) for avaliada como  verdadeira, a segunda parte (\u00e0 direita) n\u00e3o ser\u00e1 avaliada, economizando  recursos. Isso \u00e9 \u00fatil quando voc\u00ea deseja fornecer um valor padr\u00e3o se a  primeira parte for falsa.</p> <p>Exemplo: <pre><code>const userColor = 'red';\nconst defaultColor = userColor || 'black';\n\nconsole.log(defaultColor)  // red\n\nuserColor = '';\nconsole.log(defaultColor)  // black\n</code></pre></p>"},{"location":"basico/short-circuit/#conclusao","title":"Conclus\u00e3o","text":"<p>O uso de short circuit \u00e9 uma t\u00e9cnica comum em JavaScript para melhorar a  efici\u00eancia do c\u00f3digo e evitar erros desnecess\u00e1rios, especialmente ao lidar com  condi\u00e7\u00f5es e valores padr\u00e3o. No entanto, \u00e9 importante us\u00e1-lo com cuidado, pois  pode afetar a legibilidade do c\u00f3digo se n\u00e3o for usado de forma apropriada.</p>"},{"location":"basico/strings/","title":"Strings","text":"<p>Em JavaScript, uma <code>string</code> \u00e9 um tipo de dado que representa uma sequ\u00eancia de caracteres.  As strings s\u00e3o usadas para armazenar e manipular texto em JavaScript.  Uma <code>string</code> pode conter letras, n\u00fameros, s\u00edmbolos e espa\u00e7os.</p> <pre><code>// indexa\u00e7\u00e3o\n//          0123456789...\nlet text = \"O rato comeu o Queijo\";\n\nconsole.log(text[4]);   // t\nconsole.log(text[13]);  // o\nconsole.log(text[19]);  // j\nconsole.log(text[21]);  // undefined\nconsole.log(text[-1]);  // undefined\n</code></pre>"},{"location":"basico/strings/#metodos","title":"M\u00e9todos","text":""},{"location":"basico/strings/#charat","title":"charAt","text":"<pre><code>//String.charAt(pos: number): string\nconsole.log(text.charAt(3));   // a  \nconsole.log(text.charAt(21));  // ''\n</code></pre>"},{"location":"basico/strings/#concat","title":"concat","text":"<pre><code>// String.concat(...strings: string[]): string\nconsole.log(text.concat('!'));  // O rato comeu o queijo!\n</code></pre>"},{"location":"basico/strings/#indexof","title":"indexOf","text":"<pre><code>// String.indexOf(searchString: string, position?: number | undefined): number\nconsole.log(text.indexOf('comeu'));  // 7  (inicia na posi\u00e7\u00e3o 7)\nconsole.log(text.indexOf('Comeu'));  // -1 (nada foi encontrado)\n</code></pre>"},{"location":"basico/strings/#lastindexof","title":"lastIndexOf","text":"<pre><code>// String.lastIndexOf(searchString: string, position?: number | undefined): number\nconsole.log(text.lastIndexOf('o'));  // 20 (mostra a \u00faltima ocorr\u00eancia)\n</code></pre>"},{"location":"basico/strings/#match","title":"match","text":"<pre><code>// Regular Expression\nconsole.log(text.match(/[A-Z]/));  // ['O', index: 0, input: 'O rato... ] \nconsole.log(text.match(/[A-Z]/g));  // ['O', 'Q'] \n</code></pre>"},{"location":"basico/strings/#search","title":"search","text":"<pre><code>// Regular Expression\nconsole.log(text.search(/o/));  // 5 (primeira ocorr\u00eancia)\n</code></pre>"},{"location":"basico/strings/#replace","title":"replace","text":"<pre><code>// Regular Expression\nconsole.log(text.replace('o', '#'));   // O rat# comeu o Queijo\nconsole.log(text.replace(/o/, '#'));   // O rat# comeu o Queijo\nconsole.log(text.replace(/o/g, '#'));  // O rat# c#meu # Queij#\n</code></pre>"},{"location":"basico/strings/#length","title":"length","text":"<pre><code>console.log(text.length);  // 21 (do 0 ao 20)\n</code></pre>"},{"location":"basico/strings/#slice","title":"slice","text":"<pre><code>// String.slice(start?: number | undefined, end?: number | undefined): string\nconsole.log(text.slice(7, 11 + 1));  // comeu\nconsole.log(text.slice(-6));         // Queijo\nconsole.log(text.slice(-6, -3));     // Que\n</code></pre>"},{"location":"basico/strings/#split","title":"split","text":"<pre><code>console.log(text.split(' '));  // [ 'O', 'rato', 'comeu', 'o', 'Queijo' ]\nconsole.log(text.split(' ', 2));  // [ 'O', 'rato' ]\n</code></pre>"},{"location":"basico/strings/#touppercase","title":"toUpperCase","text":"<pre><code>console.log(text.toUpperCase());  // O RATO COMEU O QUEIJO\n</code></pre>"},{"location":"basico/strings/#tolowercase","title":"toLowerCase","text":"<pre><code>console.log(text.toLowerCase());  // o rato comeu o queijo\n</code></pre>"},{"location":"basico/ternary-operator/","title":"Operador Tern\u00e1rio","text":"<p>Um operador tern\u00e1rio \u00e9 um operador condicional que permite avaliar uma  express\u00e3o e retornar um valor com base em uma condi\u00e7\u00e3o. Ele \u00e9 chamado de  \"tern\u00e1rio\" porque envolve tr\u00eas operandos: a condi\u00e7\u00e3o a ser testada, o valor a  ser retornado se a condi\u00e7\u00e3o for verdadeira e o valor a ser retornado se a  condi\u00e7\u00e3o for falsa.</p> <p>A sintaxe b\u00e1sica do operador tern\u00e1rio \u00e9 a seguinte:</p> <pre><code>condi\u00e7\u00e3o ? valor_se_verdadeiro : valor_se_falso;\n</code></pre> <p>Funciona assim:</p> <ol> <li>A condi\u00e7\u00e3o \u00e9 avaliada primeiro.</li> <li>Se a condi\u00e7\u00e3o for verdadeira, o valor ap\u00f3s o ponto de interroga\u00e7\u00e3o (<code>?</code>)  \u00e9 retornado.</li> <li>Se a condi\u00e7\u00e3o for falsa, o valor ap\u00f3s os dois pontos (<code>:</code>) \u00e9 retornado.</li> </ol> <p>Exemplo:</p> <pre><code>var idade = 20;\nvar mensagem = idade &gt;= 18 ? \"Maior de idade\" : \"Menor de idade\";\n\nconsole.log(mensagem);  // O resultado ser\u00e1 \"Maior de idade\" neste caso.\n</code></pre> <p>Neste exemplo, a condi\u00e7\u00e3o <code>idade &gt;= 18</code> \u00e9 avaliada. Se for verdadeira, a string  \"Maior de idade\" \u00e9 atribu\u00edda \u00e0 vari\u00e1vel <code>mensagem</code>. Caso contr\u00e1rio, a string  \"Menor de idade\" \u00e9 atribu\u00edda.</p> <p>O operador tern\u00e1rio \u00e9 uma maneira concisa de escrever express\u00f5es condicionais  em JavaScript e pode ser \u00fatil em muitas situa\u00e7\u00f5es, como na atribui\u00e7\u00e3o de  valores com base em condi\u00e7\u00f5es simples.</p>"},{"location":"basico/values/","title":"Valores e Tipos","text":""},{"location":"basico/values/#primitivos","title":"Primitivos","text":"<p>Os valores primitivos s\u00e3o imut\u00e1veis:</p> <ul> <li>string </li> <li>number </li> <li>boolean</li> <li>undefined</li> <li>null</li> <li>bigint</li> <li>symbol</li> </ul> <p>Sempre que os atribu\u00edmos \u00e0 outra vari\u00e1veis, seus valores s\u00e3o copiados </p> <pre><code>let a = 12;\nlet b = a;  // o valor 12 \u00e9 copiado para b\nconsole.log(a, b);  // 12 12\nb = 17;\nconsole.log(a, b);  // 12 17\n</code></pre>"},{"location":"basico/values/#referencia","title":"Refer\u00eancia","text":"<p>Os valores de refer\u00eancia s\u00e3o mut\u00e1veis:</p> <ul> <li>array</li> <li>object</li> <li>function</li> </ul> <p>Sempre que os atribu\u00edmos \u00e0 outra vari\u00e1vel, a nova vari\u00e1vel aponta para o mesmo endere\u00e7o na mem\u00f3ria</p> <pre><code>const c = [1, 2, 3];\nconst d = c;  // a vari\u00e1vel d aponta para o mesmo endere\u00e7o de mem\u00f3ria que c\n\nconsole.log(c, d);  // [1, 2, 3] [1, 2, 3]\nd.push(4);\nconsole.log(c, d);  // [1, 2, 3, 4] [1, 2, 3, 4]\n\n\n// para fazer uma c\u00f3pia, podemos usar o spread operator `...`\nconst e = [...d]\n\nconsole.log(d, e);  // [1, 2, 3, 4] [1, 2, 3, 4]\ne.pop();\nconsole.log(d, e);  // [1, 2, 3, 4] [1, 2, 3]\n\n\n// mesmo exemplo com object\nconst f = { name: 'Cesar', age: 53 }\nconst g = { ...f }\n\nf.name = 'Jady'\nconsole.log(f, g);\n</code></pre>"},{"location":"basico/values/#tipos","title":"Tipos","text":""},{"location":"basico/values/#strings","title":"strings","text":"<pre><code>const firstName = \"Cesar\";\nconst lastName = 'Godoi';\nconst cityOfBirth = `Bauru`;\n</code></pre>"},{"location":"basico/values/#numbers","title":"numbers","text":"<pre><code>const integer = 12;\nconst float = 12.34;\n</code></pre>"},{"location":"basico/values/#undefined","title":"undefined","text":"<pre><code>let country;\nvar district;\n</code></pre>"},{"location":"basico/values/#null","title":"null","text":"<pre><code>const dog = null;\n</code></pre>"},{"location":"basico/values/#boolean","title":"boolean","text":"<pre><code>const exist = true;\nconst doesNotExist = false;\n</code></pre>"},{"location":"basico/values/#symbol","title":"symbol","text":"<pre><code>const symbl = Symbol('\u00e9 nois');\n</code></pre>"},{"location":"basico/values/#typeof","title":"typeof","text":"<p>Podemos usar o m\u00e9todo <code>typeof</code> para descobrir o tipo de uma vari\u00e1vel ou constante. <pre><code>console.log(`${cityOfBirth} = ${typeof cityOfBirth}`);\nconsole.log(`${float} = ${typeof float}`);\nconsole.log(`${country} = ${typeof country}`);\nconsole.log(`${dog} = ${typeof dog}`);  // o typeof de null ser\u00e1 object (bug do javascript)\nconsole.log(`${doesNotExist} = ${typeof doesNotExist}`);\nconsole.log(`${typeof symbl} descr: ${symbl.description}`);\n</code></pre></p>"},{"location":"basico/variables/","title":"Vari\u00e1veis e Constantes","text":""},{"location":"basico/variables/#let-e-var","title":"let e var","text":"<p>Em javascript podemos usar <code>let</code> e <code>var</code> para declarar vari\u00e1veis. No entanto devemos dar prefer\u00eancia ao <code>let</code>, pois \u00e9 mais moderna (ECMAScript 2015 - ES6).   </p> <p><code>let</code> tem escopo de bloco   <code>var</code>  tem escopo de fun\u00e7\u00e3o</p> <p>Regra Geral e boas pr\u00e1ticas para se nomear vari\u00e1veis no javascript:  </p> <ul> <li>Vari\u00e1veis s\u00e3o case-sensitive (diferencia mai\u00fasculas de min\u00fasculas);   </li> <li>N\u00e3o podemos criar vari\u00e1veis com palavras reservadas do javascript;   </li> <li>N\u00e3o podemos usar espa\u00e7os ' ' ou hifen '-';   </li> <li>N\u00e3o podemos come\u00e7ar o nome da vari\u00e1vel com n\u00fameros;   </li> <li>Vari\u00e1veis precisam ter nomes significativos   </li> <li>Utilizamos nota\u00e7\u00e3o camelCase</li> <li>N\u00e3o podemos redeclarar vari\u00e1veis com <code>let</code></li> <li>Sempre d\u00ea prefer\u00eancia em usar <code>let</code> ao inv\u00e9s de <code>var</code> </li> </ul> <pre><code>let name;  // vari\u00e1vel declarada sem nenhum valor atribuido \nconsole.log(name);  // returns undefined\n\nname = \"Maria Eneida\";\nconsole.log(name);  // retorna Maria Eneida\n\nlet otherName = \"Cesar Godoi\";  // vari\u00e1vel declarada com valor atribuido\nconsole.log(otherName);  // returno Cesar Godoi\n\n\nvar cidade = \"S\u00e3o Paulo\";  // vari\u00e1vel declarada com valor atribu\u00eddo\nconsole.log(cidade);  // retorna S\u00e3o Paulo\n\nvar cidade = \"Bauru\";  // 'var' pode ser re-declarada sem provocar erro\nconsole.log(cidade);  // retorna Bauru\n</code></pre>"},{"location":"basico/variables/#const","title":"const","text":"<p>Em javascript n\u00f3s usamos <code>const</code> para declarar constantes.</p> <p>No que diz respeito \u00e0s regras e boas pr\u00e1ticas na nomea\u00e7\u00e3o de constantes,  podemos dizer que al\u00e9m das descritas para <code>let</code> e <code>var</code>, temos as seguintes:</p> <ul> <li>Constantes precisam ser atribu\u00eddas com um valor ao serem declaradas;</li> <li>N\u00e3o podemos redeclarar constantes com <code>constant</code>;</li> <li>Sempre d\u00ea prefer\u00eancia em usar <code>const</code> ao inv\u00e9s de <code>let</code> ou <code>var</code> (quando poss\u00edvel);</li> </ul> <pre><code>const pi = 3.14;\nconsole.log(pi);  // retorna 3.14\n</code></pre>"},{"location":"basico/arrays/arrays/","title":"Arrays","text":"<p>Um <code>array</code> em JavaScript \u00e9 uma estrutura de dados que permite armazenar uma  cole\u00e7\u00e3o de elementos em uma \u00fanica vari\u00e1vel. Os elementos em um <code>array</code> podem  ser de qualquer tipo de dados, como <code>n\u00fameros</code>, <code>strings</code>, <code>objetos</code>, <code>fun\u00e7\u00f5es</code>  e at\u00e9 outros <code>arrays</code>.  Cada elemento em um <code>array</code> \u00e9 acessado por um <code>\u00edndice</code>, que \u00e9 um n\u00famero  inteiro que representa a posi\u00e7\u00e3o do elemento no <code>array</code>.</p> <p>Vamos considerar o seguinte <code>array</code> abaixo:  </p> <pre><code>const alunos = ['Cesar', 'Ot\u00e1vio', 'Jady'];\nconsole.log(alunos);                   // ['Cesar', 'Ot\u00e1vio', 'Jady']\nconsole.log(typeof alunos);            // object\nconsole.log(alunos instanceof Array);  // true\n</code></pre> <p>Podemos acessar os elementos do <code>array</code> \u00e0 partir dos seus <code>\u00edndices</code>: <pre><code>console.log(alunos[0]);   // Cesar\nconsole.log(alunos[10]);  // undefined\n</code></pre></p> <p>Tamb\u00e9m \u00e9 possivel atualizar um elemento do <code>array</code> usando o seu <code>\u00edndice</code>: <pre><code>alunos[1] = 'Floriano';\nconsole.log(alunos);  // ['Cesar', 'Floriano', 'Jady']\n</code></pre></p> <p>Podemos inserir um novo elemento a um <code>array</code> apontando esse elemento para um  <code>\u00edndice</code> maior do que o \u00faltimo <code>\u00edndice</code> do <code>array</code>. <pre><code>alunos[3] = 'Ot\u00e1vio';\nconsole.log(alunos);  // ['Cesar', 'Floriano', 'Jady', 'Ot\u00e1vio']\n</code></pre></p>"},{"location":"basico/arrays/arrays/#metodos","title":"M\u00e9todos","text":""},{"location":"basico/arrays/arrays/#push","title":"push","text":"<p>Adiciona um elemento ao final da lista <pre><code>alunos.push('Fon');\nconsole.log(alunos);  // ['Cesar', 'Floriano', 'Jady', 'Ot\u00e1vio', 'Fon']\n</code></pre></p>"},{"location":"basico/arrays/arrays/#unshift","title":"unshift","text":"<p>adiciona um elemento ao in\u00edcio da lista <pre><code>alunos.unshift('Edu');\nconsole.log(alunos);  // ['Edu', 'Cesar', 'Floriano', 'Jady', 'Ot\u00e1vio', 'Fon']\n</code></pre></p>"},{"location":"basico/arrays/arrays/#pop","title":"pop","text":"<p>remove o \u00faltimo elemento <pre><code>alunos.pop();\nconsole.log(alunos);                    // ['Edu', 'Cesar', 'Floriano', 'Jady', 'Ot\u00e1vio']\nlet removido = alunos.pop();            // remove o \u00faltimo elemento e o atribui \u00e0 vari\u00e1vel removido\nconsole.log(`removido = ${removido}`);  // removido = Ot\u00e1vio\nconsole.log(alunos);                    // ['Edu', 'Cesar', 'Floriano', 'Jady']\n</code></pre></p>"},{"location":"basico/arrays/arrays/#shift","title":"shift","text":"<p>remove o primeiro elemento  <pre><code>alunos.shift();\nconsole.log(alunos);                    // ['Cesar', 'Floriano', 'Jady']\nremovido = alunos.shift();              // remove o primeiro elemento e o atribui \u00e0 vari\u00e1vel removido\nconsole.log(`removido = ${removido}`);  // removido = Cesar\nconsole.log(alunos);                    // ['Floriano', 'Jady']\n</code></pre></p>"},{"location":"basico/arrays/arrays/#delete","title":"delete","text":"<p>apaga o conte\u00fado de um \u00edndice <pre><code>delete alunos[0];\nconsole.log(alunos);  // [&lt;1 empty item&gt;, 'Jady']\n\n// ajustar a lista para os proximos exemplos\nalunos[0] = 'Cesar';\nalunos.push('Edu');\nalunos.push('Ot\u00e1vio');\nconsole.log(alunos);\n</code></pre></p>"},{"location":"basico/arrays/arrays/#slice","title":"slice","text":"<p>seleciona elementos sequenciais <pre><code>console.log(alunos.slice(0, 2));  // ['Cesar', 'Jady']\nconsole.log(alunos.slice(-2));    // ['Edu', 'Ot\u00e1vio']\n</code></pre></p>"},{"location":"basico/arrays/arrays/#join","title":"join","text":"<p>transforma um array em uma string <pre><code>const nomesAlunos = alunos.join(' ');\nconsole.log(nomesAlunos);  // Cesar Jady Edu Ot\u00e1vio \n</code></pre></p>"},{"location":"basico/arrays/arrays/#concat","title":"concat","text":"<p>concatena arrays <pre><code>const arr1 = [1, 2, 3];\nconst arr2 = [4, 5, 6];\nconst arr3 = arr1.concat(arr2, [7, 8, 9], 'Cesar');\nconsole.log(arr3);  // [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 'Cesar' ]\n</code></pre></p>"},{"location":"basico/arrays/arrays/#spread-operator","title":"spread operator <code>...</code>","text":"<p>usando o spread operator para concatenar <code>strings</code> <pre><code>const arr4 = [...arr1, 'Cesar', ...arr2, ...[7, 8, 9]];\nconsole.log(arr4);  // [ 1, 2, 3, 'Cesar', 4, 5, 6, 7, 8, 9 ]\n</code></pre></p>"},{"location":"basico/arrays/arrays/#splice","title":"splice","text":"<p>O m\u00e9todo <code>splice()</code> \u00e9 usado para alterar o conte\u00fado de um array, adicionando,  removendo ou substituindo elementos. Ele pode ser usado de v\u00e1rias maneiras e  possui os seguintes par\u00e2metros:</p> <pre><code>array.splice(start, deleteCount, item1, item2, ...)\n</code></pre> <ul> <li><code>start</code>: O \u00edndice no array a partir do qual as altera\u00e7\u00f5es devem come\u00e7ar.</li> <li><code>deleteCount</code>: O n\u00famero de elementos a serem removidos a partir do <code>start</code>.  Se for zero, nenhum elemento ser\u00e1 removido.</li> <li><code>item1, item2, ...</code>: Elementos a serem inseridos no array no lugar dos  elementos removidos.</li> </ul> <p>O m\u00e9todo <code>splice()</code> retorna um novo array contendo os elementos removidos.</p> <p>Aqui est\u00e3o alguns exemplos de como o m\u00e9todo <code>splice()</code> pode ser usado:</p>"},{"location":"basico/arrays/arrays/#remover-elementos","title":"Remover elementos","text":"<pre><code>const arr = [1, 2, 3, 4, 5];\nconst removed = arr.splice(1, 2);  // Remove 2 elementos a partir do \u00edndice 1\nconsole.log(arr);                  // [1, 4, 5]\nconsole.log(removed);              // [2, 3]\n</code></pre> <p>Simulando <code>pop</code> e <code>shift</code>: <pre><code>const arr = ['a', 'b', 'c', 'd', 'e'];\nconst removed = arr.splice(-1, 1);   // Remove 'e'  =  arr.pop()\nconsole.log(arr);                    // ['a', 'b', 'c', 'd']\nconsole.log(removed);                // ['e']\nconst removed2 = arr.splice(0, 1);   // Remove 'a'  =  arr.shift()\nconsole.log(arr);                    // ['b', 'c', 'd']\nconsole.log(removed2);               // ['a']\n</code></pre></p>"},{"location":"basico/arrays/arrays/#inserir-elementos","title":"Inserir elementos","text":"<pre><code>const arr = [1, 2, 3, 4, 5];\narr.splice(2, 0, 6, 7);   // Insere os elementos 6 e 7 a partir do \u00edndice 2\nconsole.log(arr);         // [1, 2, 6, 7, 3, 4, 5]\n</code></pre> <p>Simulando <code>push</code> e <code>unshift</code>: <pre><code>const arr = ['b', 'c', 'd'];\narr.splice(arr.length, 0, 'e');      // Adiciona 'e'  =  arr.push('e')\nconsole.log(arr);                    // ['b', 'c', 'd', 'e']\narr.splice(0, 0, 'a');               // Adiciona 'a'  =  arr.unshift('a')\nconsole.log(arr);                    // ['a', 'b', 'c', 'd', 'e']\n</code></pre></p>"},{"location":"basico/arrays/arrays/#substituir-elementos","title":"Substituir elementos","text":"<pre><code>const arr = [1, 2, 3, 4, 5];\narr.splice(2, 2, 6, 7);   // Substitui os elementos 3 e 4 pelos elementos \n                          // 6 e 7 a partir do \u00edndice 2\nconsole.log(arr);         // [1, 2, 6, 7, 5]\n</code></pre> <p>Tenha em mente que o m\u00e9todo <code>splice()</code> modifica o array original, e os  elementos removidos s\u00e3o retornados em um novo array. Portanto, \u00e9 uma opera\u00e7\u00e3o  destrutiva. Certifique-se de entender como o m\u00e9todo funciona e de que forma  ele afetar\u00e1 o seu array antes de utiliz\u00e1-lo.</p>"},{"location":"fun%C3%A7%C3%B5es/closures/","title":"Closures","text":"<p>Uma \"closure\" \u00e9 uma fun\u00e7\u00e3o que \"lembra\" o ambiente em que foi criada, incluindo  todas as vari\u00e1veis locais e par\u00e2metros da fun\u00e7\u00e3o exterior a ela. Isso permite  que a fun\u00e7\u00e3o tenha acesso a essas vari\u00e1veis mesmo ap\u00f3s a fun\u00e7\u00e3o externa ter  sido conclu\u00edda e retornada. As closures s\u00e3o uma caracter\u00edstica poderosa da  linguagem e t\u00eam v\u00e1rias aplica\u00e7\u00f5es.</p> <p>Para entender melhor as closures, \u00e9 importante ter em mente os seguintes  conceitos:</p> <ol> <li> <p>Fun\u00e7\u00f5es aninhadas: Em JavaScript, voc\u00ea pode definir fun\u00e7\u00f5es dentro de outras  fun\u00e7\u00f5es. A fun\u00e7\u00e3o interna \u00e9 chamada de fun\u00e7\u00e3o aninhada.</p> </li> <li> <p>Escopo l\u00e9xico: Em JavaScript, as fun\u00e7\u00f5es s\u00e3o definidas com base em um escopo  l\u00e9xico, o que significa que elas t\u00eam acesso \u00e0s vari\u00e1veis de seu ambiente pai  (fun\u00e7\u00e3o que a envolve).</p> </li> </ol> <p>Uma closure ocorre quando uma fun\u00e7\u00e3o interna (fun\u00e7\u00e3o aninhada) \u00e9 retornada de  uma fun\u00e7\u00e3o externa e, em seguida, \u00e9 chamada fora do escopo da fun\u00e7\u00e3o externa. </p> <p>Aqui est\u00e1 um exemplo simples de uma closure:</p> <pre><code>function outerFunction(inicio) {\n    let [var1, var2, var3] = \"&lt;| || |&gt;\".split(' ');\n\n    function innerFunction(fim) {\n        return `${var1} ${inicio} ${var2} ${fim} ${var3}`;\n    }\n\n    return innerFunction; // Retorna a fun\u00e7\u00e3o interna\n}\n\nconst teste = outerFunction('Aqui \u00e9 o in\u00edcio');\nconsole.log(teste('aqui o fim'));  // &lt;| Aqui \u00e9 o in\u00edcio || aqui o fim |&gt;\n</code></pre> <p>Neste exemplo, <code>innerFunction</code> \u00e9 uma closure porque ela \"lembra\" o escopo de  <code>outerFunction</code> mesmo ap\u00f3s a <code>outerFunction</code> ter retornado e foi atribu\u00edda a  <code>closure</code>.</p> <p>As closures s\u00e3o \u00fateis para criar fun\u00e7\u00f5es que encapsulam estados e  comportamentos espec\u00edficos, permitindo que voc\u00ea crie fun\u00e7\u00f5es que mantenham  informa\u00e7\u00f5es entre chamadas, como fun\u00e7\u00f5es de f\u00e1brica, geradores, manipuladores  de eventos e muito mais. Elas s\u00e3o uma parte fundamental do JavaScript e  desempenham um papel importante na cria\u00e7\u00e3o de c\u00f3digo flex\u00edvel e reutiliz\u00e1vel.</p> <p>Um exemplo mais pr\u00e1tico:</p> <pre><code>function multiplicador(multipl) {\n    return function (num) {\n        return num * multipl;\n    }\n}\n\nconst duplica = multiplicador(2);\nconst triplica = multiplicador(3);\n\nconsole.log(duplica(35));  // 70\nconsole.log(triplica(35));  // 105\n</code></pre>"},{"location":"fun%C3%A7%C3%B5es/constructor-function/","title":"Constructor function","text":"<p>Uma <code>constructor function</code> \u00e9 uma fun\u00e7\u00e3o que \u00e9 usada para criar objetos. Ela  atua como um \"modelo\" para criar m\u00faltiplos objetos com as mesmas propriedades  e m\u00e9todos.</p> <p>Aqui est\u00e1 um exemplo de constructor function:</p> <pre><code>function Pessoa(nome, sobrenome, alt, pes) {\n    const secret = '12bf4W';  // atributo privado\n\n    this.nome = nome;\n    this.sobrenome = sobrenome;\n    this.altura = alt;\n    this.peso = pes;\n\n    this.nomeCompleto = `${this.nome} ${this.sobrenome}`;\n    this.imc = (this.peso / (this.altura ** 2)).toFixed(2);\n\n    this.fala = (assunto) =&gt; {\n        return `${this.nome} disse ${assunto}`;\n    };\n\n}\n</code></pre> <p>Neste exemplo podemos instanciar novas pessoas, usando a palavra-chave <code>new</code>.</p> <pre><code>const pessoa1 = new Pessoa('Arnaldo', 'Fagundes', 1.87, 102);\nconsole.log(pessoa1.secret);          // atributo privado: acesso proibido\nconsole.log(pessoa1);                 // { nome: 'Arnaldo', ... }\nconsole.log(pessoa1.nomeCompleto);    // Arnaldo Fagundes\nconsole.log(pessoa1.fala('python'));  // Arnaldo dissee python\nconsole.log(pessoa1.imc);             // 29.17\n</code></pre> <p>A principal vantagem das constructor functions \u00e9 a capacidade de criar objetos  com a mesma estrutura e comportamento de uma maneira mais organizada e  reutiliz\u00e1vel. Elas s\u00e3o frequentemente usadas em conjunto com prot\u00f3tipos para  adicionar m\u00e9todos compartilhados entre as inst\u00e2ncias dos objetos criados a  partir da constructor function.</p>"},{"location":"fun%C3%A7%C3%B5es/factory-function/","title":"Factory function","text":"<p>Uma <code>factory function</code> \u00e9 uma fun\u00e7\u00e3o que cria e retorna objetos. Ela \u00e9 usada  para encapsular a cria\u00e7\u00e3o de objetos, o que pode ser \u00fatil para criar v\u00e1rias  inst\u00e2ncias de objetos sem a necessidade de escrever c\u00f3digo repetitivo.</p> <p>A principal caracter\u00edstica de uma <code>factory function</code> \u00e9 que ela encapsula a  l\u00f3gica de cria\u00e7\u00e3o de um objeto em uma fun\u00e7\u00e3o e retorna novas inst\u00e2ncias desse  objeto toda vez que \u00e9 invocada. Essa abordagem \u00e9 uma forma de implementar o  conceito de \"fabrica\u00e7\u00e3o\" de objetos, onde a fun\u00e7\u00e3o age como uma f\u00e1brica que  produz objetos com base em um modelo ou estrutura predefinida.</p> <p>Vejamos um exemplo simples de uma <code>factory function</code>:</p> <pre><code>function criarPessoa(name, idade) {\n  return {\n    name,  // quando o a chave do argumento vai ser a mesma do retorno n\u00e3o \n           // precisamos escrever -&gt; name: name\n    age: idade,\n    cumprimentar: function() {\n      console.log(`Ol\u00e1, meu nome \u00e9 ${this.name} e tenho ${this.age} anos.`);\n    },\n    ficarMaisVelho(anos = 1) {\n        return this.age += anos;\n    }\n  };\n}\n</code></pre> <p>Neste exemplo, a fun\u00e7\u00e3o <code>criarPessoa</code> \u00e9 uma <code>factory function</code> que cria  objetos pessoa com as propriedades <code>name</code>, <code>idade</code> e dois m\u00e9todos:   </p> <ul> <li><code>cumprimentar</code></li> <li><code>ficarMaisVelho</code></li> </ul> <pre><code>var pessoa1 = criarPessoa(\"Jo\u00e3o\", 30);\nvar pessoa2 = criarPessoa(\"Maria\", 25);\n\npessoa1.cumprimentar();     // Ol\u00e1, meu nome \u00e9 Jo\u00e3o e tenho 30 anos.\npessoa2.cumprimentar();     // Ol\u00e1, meu nome \u00e9 Maria e tenho 25 anos.\n\npessoa1.ficarMaisVelho();   // aumenta 1 ano para Jo\u00e3o\npessoa1.cumprimentar();     // Ol\u00e1, meu nome \u00e9 Jo\u00e3o e tenho 31 anos.\n\npessoa2.ficarMaisVelho(4);  // aumenta 4 anos para Maria\npessoa2.cumprimentar();     // Ol\u00e1, meu nome \u00e9 Maria e tenho 29 anos.\n</code></pre>"},{"location":"fun%C3%A7%C3%B5es/factory-function/#getters-e-setters","title":"getters e setters","text":"<p><code>Factory functions</code> podem ter getters e setters.  Isso permite controlar o  acesso e a modifica\u00e7\u00e3o das propriedades do objeto de forma mais precisa, se  necess\u00e1rio.</p> <pre><code>function pessoa(nome, sobrenome, alt, pes) {\n    return {\n        nome,\n        sobrenome,\n        // get -&gt; getter\n        get nomeCompleto() {\n            return `${this.nome} ${this.sobrenome}`;\n        },\n        // set -&gt; setter\n        set nomeCompleto(text) {\n            text = text.split(' ');\n            this.nome = text.shift();\n            this.sobrenome = text.join(' ');\n        },\n        altura: alt,\n        peso: pes,\n        fala(assunto) {\n            return `${this.nome} est\u00e1 falando sobre ${assunto}`;\n        },\n\n        get imc() {\n            return (this.peso / (this.altura ** 2)).toFixed(2);\n        }\n    }\n}\n\nconst p1 = pessoa('Jucelino', 'Guanabara', 1.87, 106);\nconsole.log(p1);  \n// { nome: 'Jucelino', sobrenome: 'Guanabara', nomeCompleto: [Getter/Setter], \n//   altura: 1.87, peso: 106, fala: [Function: fala], imc: [Getter] }\nconsole.log(p1.nomeCompleto);  // Jucelino Guanabara \nconsole.log(p1.fala('JavaScript'));  // Jucelino est\u00e1 falando sobre JavaScript\nconsole.log(p1.imc);  // 30.31\np1.nomeCompleto = 'Tiburcio Caetano';\nconsole.log(p1.nomeCompleto);  // Tiburcio Caetano\n</code></pre>"},{"location":"fun%C3%A7%C3%B5es/function-declaration/","title":"Declara\u00e7\u00e3o de fun\u00e7\u00f5es","text":"<p>Em JavaScript, voc\u00ea pode declarar fun\u00e7\u00f5es de v\u00e1rias maneiras. As formas mais  comuns de declarar fun\u00e7\u00f5es s\u00e3o a <code>function declaration</code> (forma tradicional),  a <code>function expression</code> e temos tamb\u00e9m as <code>arrow functions</code>.</p>"},{"location":"fun%C3%A7%C3%B5es/function-declaration/#function-declaration","title":"function declaration","text":"<pre><code>function nomeDaFuncao(parametros) {\n    // corpo da fun\u00e7\u00e3o\n    return resultado  // pode ou n\u00e3o retornar um resultado\n}\n</code></pre> <p>Para fun\u00e7\u00f5es tradicionais, ocorre o <code>hoisting</code>, que \u00e9 a eleva\u00e7\u00e3o dessas fun\u00e7\u00f5es  para o in\u00edcio do script em tempo de execu\u00e7\u00e3o, o que permite invocar (em tempo  de desenvolvimento) a fun\u00e7\u00e3o, mesmo antes dela ser declarada.</p> <pre><code>falaOie();     // fun\u00e7\u00e3o invocada antes da sua declara\u00e7\u00e3o  -&gt;  oie\n\nfunction falaOie() {\n    console.log('oie');\n}\n</code></pre>"},{"location":"fun%C3%A7%C3%B5es/function-declaration/#function-expression","title":"Function expression","text":"<p>O fato de as fun\u00e7\u00f5es serem objetos de primeira classe (first-class objects),  nos permite atribu\u00ed-las \u00e0 vari\u00e1veis.  Isso justifica esta segunda forma de  declarar nossas fun\u00e7\u00f5es.</p> <pre><code>const dobra = function (num) {\n    return num * 2;\n}\n\nconsole.log(dobra(2));   // 4\n</code></pre> <p>Podemos inclusive receber uma fun\u00e7\u00e3o como um par\u00e2metro de outra fun\u00e7\u00e3o.</p> <pre><code>function executaFuncao(funcao) {\n    console.log('O resultado da fun\u00e7\u00e3o \u00e9:');\n    funcao();\n}\nexecutaFuncao(falaOie);   // O resultado da fun\u00e7\u00e3o \u00e9:\n                          // oie\n</code></pre>"},{"location":"fun%C3%A7%C3%B5es/function-declaration/#arrow-function","title":"Arrow function","text":"<p>\u00c9 a forma mais moderna de declararmos uma fun\u00e7\u00e3o</p> <pre><code>const funcArrow = () =&gt; {\n    console.log('sou uma arrow function');\n}\nfuncArrow();  // sou uma arrow function\n</code></pre> <p>Podemos atribuir uma fun\u00e7\u00e3o \u00e0 um parametro de um objeto</p> <pre><code>const pessoa = {\n    nome: 'Cesar',\n    // falar: () =&gt; console.log('e a\u00ed, tudo bem?'),  // com arrow\n    falar() { console.log('e a\u00ed, tudo bem?') },      // nova forma\n}\nconsole.log(pessoa.nome);  // Cesar\npessoa.falar();            // e a\u00ed, tudo bem?\n</code></pre>"},{"location":"fun%C3%A7%C3%B5es/generators/","title":"Generators","text":""},{"location":"fun%C3%A7%C3%B5es/generators/#definicao","title":"Defini\u00e7\u00e3o","text":"<p>Um generator \u00e9 uma fun\u00e7\u00e3o especial que permite pausar e retomar sua execu\u00e7\u00e3o.  Isso \u00e9 \u00fatil quando voc\u00ea precisa lidar com opera\u00e7\u00f5es demoradas ou iterar sobre  um grande conjunto de dados de forma eficiente. Os generators s\u00e3o criados  usando a fun\u00e7\u00e3o <code>function*</code>.</p> <p>Existe tamb\u00e9m sintaxe mais recente <code>async function*</code>, que introduz o  conceito de \"async generators\" para trabalhar com opera\u00e7\u00f5es ass\u00edncronas. Veremos isso no futuro.</p> <p>Generators s\u00e3o \u00fateis em v\u00e1rias situa\u00e7\u00f5es, como itera\u00e7\u00e3o pregui\u00e7osa sobre  grandes conjuntos de dados, lidar com c\u00f3digo ass\u00edncrono de forma mais leg\u00edvel  e criar pipelines de processamento de dados. Eles s\u00e3o uma caracter\u00edstica  poderosa do JavaScript que simplifica muitos aspectos do c\u00f3digo ass\u00edncrono e  da manipula\u00e7\u00e3o de sequ\u00eancias de dados.</p>"},{"location":"fun%C3%A7%C3%B5es/generators/#estrutura","title":"Estrutura","text":"<p>Para criar um generator, voc\u00ea usa a fun\u00e7\u00e3o <code>function*</code> e dentro dela, voc\u00ea  pode usar a instru\u00e7\u00e3o <code>yield</code>. O <code>yield</code> \u00e9 usado para pausar a execu\u00e7\u00e3o da  fun\u00e7\u00e3o e retornar um valor. Quando a fun\u00e7\u00e3o \u00e9 retomada, ela continua a partir  do ponto em que foi pausada, mantendo seu estado interno.</p> <pre><code>function* nomeDoGenerator() {\n    yield elementoGerado;\n}\n</code></pre> <p>A cada vez que chamamos o atributo <code>next</code> do generator, ele nos entrega um  elemento da itera\u00e7\u00e3o, como demonstrado abaixo: </p> <pre><code>{ value: 'elementoSendoEntregue', done: false }\n</code></pre> <p>Quando os elementos gerados chegam ao fim, o atributo <code>done</code> do objeto entregue  ser\u00e1 igual a <code>true</code> e o elemento entregue ser\u00e1 <code>undefined</code>.</p> <p>Caso usemos o <code>return</code>, ele encerrar\u00e1 o generator, excluindo qualquer <code>yield</code>  que venha ap\u00f3s ele.</p>"},{"location":"fun%C3%A7%C3%B5es/generators/#exemplos","title":"Exemplos","text":""},{"location":"fun%C3%A7%C3%B5es/generators/#basico","title":"B\u00e1sico","text":"<pre><code>function* myGenerator() {\n    yield 'elemento 1';\n    yield 'elemento 2';\n    yield 'elemento 3';\n    yield 'elemento 4';\n}\n\nconst gen1 = myGenerator();\nconsole.log(gen1);               // Object [Generator] {}\nconsole.log(gen1.next());        // { value: 'elemento 1', done: false }\nconsole.log(gen1.next().value);  // elemento 2\nconsole.log(gen1.next().value);  // elemento 3\nconsole.log(gen1.next().value);  // elemento 4\nconsole.log(gen1.next());        // { value: undefined, done: true }\n\n// iterando com for\nconst gen2 = myGenerator();\nfor (val of gen2) {\n    console.log(val);\n}\n</code></pre>"},{"location":"fun%C3%A7%C3%B5es/generators/#gerador-infinito","title":"Gerador infinito","text":"<pre><code>function* contador() {\n  let i = 0;\n  while (true) {\n    yield i;\n    i++;\n  }\n}\n\nconst gen = contador();\n\nconsole.log(gen.next().value); // 0\nconsole.log(gen.next().value); // 1\nconsole.log(gen.next().value); // 2\n</code></pre> <p>Neste exemplo, a fun\u00e7\u00e3o <code>contador</code> \u00e9 um generator que gera uma sequ\u00eancia  infinita de n\u00fameros inteiros come\u00e7ando por zero. O <code>yield</code> pausa a execu\u00e7\u00e3o da  fun\u00e7\u00e3o e retorna o valor atual de <code>i</code>, e o m\u00e9todo <code>next()</code> \u00e9 usado para  avan\u00e7ar para o pr\u00f3ximo valor da sequ\u00eancia.</p>"},{"location":"fun%C3%A7%C3%B5es/generators/#unindo-dois-geradores","title":"Unindo dois geradores","text":"<pre><code>function* generator1() {\n    yield 1;\n    yield 2;\n    yield 3;\n    yield 4;\n}\n\nfunction* generator2() {\n    yield* generator1();\n    yield 5;\n    yield 6;\n    yield 7;\n}\n\nlet gen4 = generator2()\nfor (val of gen4) {\n    console.log(val);  // itera de 1 \u00e0 7\n}\n</code></pre>"},{"location":"fun%C3%A7%C3%B5es/generators/#entregando-funcoes","title":"Entregando fun\u00e7\u00f5es","text":"<pre><code>function* getFunction() {\n    yield function () {\n        console.log('vim do 1. yield');\n    }\n    yield function () {\n        console.log('vim do 2. yield');\n    }\n    return function () {\n        console.log('vim do return');\n    }\n}\n\nlet gen5 = getFunction();\n\nconst func1 = gen5.next().value;\nconst func2 = gen5.next().value;\nconst func3 = gen5.next().value;\n\nfunc1();  // vim do 1. yield\nfunc2();  // vim do 2. yield\nfunc3();  // vim do return\n</code></pre>"},{"location":"fun%C3%A7%C3%B5es/parameters/","title":"Parametros","text":"<p>Os par\u00e2metros de fun\u00e7\u00e3o s\u00e3o os valores que podemos passar para uma fun\u00e7\u00e3o  quando a chamamos. Os par\u00e2metros permitem que forne\u00e7amos dados de entrada para  uma fun\u00e7\u00e3o, que a fun\u00e7\u00e3o pode ent\u00e3o usar em seu corpo para executar uma tarefa  espec\u00edfica. Os par\u00e2metros s\u00e3o definidos na declara\u00e7\u00e3o de fun\u00e7\u00e3o e atuam como  vari\u00e1veis locais dentro do escopo da fun\u00e7\u00e3o.</p> <pre><code>function soma(a, b) {\n    return a + b;\n}\n\nsoma(10, 45);  // 55\n</code></pre>"},{"location":"fun%C3%A7%C3%B5es/parameters/#arguments","title":"Arguments","text":"<p>No JavaScript, quando n\u00e3o declaramos os argumentos necess\u00e1rios numa fun\u00e7\u00e3o, mas  vamos invoc\u00e1-la passando algum argumento, o JavaScript n\u00e3o causa erros, pois armazena todos estes argumentos numa vari\u00e1vel especial chamada: <code>arguments</code></p> <pre><code>function getArgs() {\n    console.log(arguments);\n}\n\ngetArgs('cavalo', 'lambreta', 123, 45);  // [Arguments] { '0': 'cavalo', '1': 'lambreta', '2': 123, '3': 45 }\n\nfunction getArgs2(a, b) {\n    console.log(a, b, arguments);\n}\n\ngetArgs2('\u00c9gua', 'moto', 12);  // \u00c9gua moto [Arguments] { '0': '\u00c9gua', '1': 'moto', '2': 12 }\n</code></pre> <p>Embora n\u00e3o tenhamos 'arguments' em arrow functions, podemos usar o  <code>spread operator</code> para trabalhar da mesma forma.</p> <pre><code>const myNumbers = (...args) =&gt; {\n    console.log(args);\n}\nmyNumbers(1, 2, 3, 4, 5, 6, 7, 8);  // [1, 2, 3, 4, 5, 6, 7, 8]\n</code></pre>"},{"location":"fun%C3%A7%C3%B5es/parameters/#valor-padrao","title":"Valor padr\u00e3o","text":"<p>Tamb\u00e9m podemos pr\u00e9-determinar o valor padr\u00e3o de algum par\u00e2metro, assim, caso  no at\u00f3 de invocar uma fun\u00e7\u00e3o, nenhum valor seja passado ao par\u00e2metro, a fun\u00e7\u00e3o vai assumir o valor padr\u00e3o.</p> <pre><code>function multiplica(a, b = 1, c = 21) {\n    return a * b + c;\n}\n\nconsole.log(multiplica(23, 12, 4));         // 280\nconsole.log(multiplica(27));                // 48\nconsole.log(multiplica(3, 3));              // 30\nconsole.log(multiplica(4, undefined, 16));  // 20\n</code></pre>"},{"location":"fun%C3%A7%C3%B5es/parameters/#destructuring","title":"Destructuring","text":"<p>Destructuring \u00e9 uma forma de extrair valores de objetos ou arrays e atribu\u00ed-los  a vari\u00e1veis de forma mais concisa. Isso pode tornar o c\u00f3digo mais leg\u00edvel e  facilitar a manipula\u00e7\u00e3o de dados. </p> <pre><code>function gessNumbers([num1, num2, num3]) {\n    console.log(num1, num2, num3);\n}\n\ngessNumbers([134, 475, 65]);  // 134 475 65\n\nfunction fullName({ name, lastname }) {\n    console.log(name, lastname);\n}\n\nfullName({ name: 'Cesar', lastname: 'Godoi' });  // Cesar Godoi\n</code></pre>"},{"location":"fun%C3%A7%C3%B5es/parameters/#exemplo","title":"Exemplo","text":"<p>Considere a seguinte fun\u00e7\u00e3o que recebe como primeiro artumento um operador  e uma lista de n\u00fameros que devem ser processados de acordo com o  operador.</p> <pre><code>function calc(oper, ...numbers) {\n    if (oper === '+') {\n        let sum = 0;\n        numbers.forEach((num) =&gt; sum += num);\n        return sum;\n    }\n    if (oper === '-') {\n        let sub = Math.max(...numbers);\n        numbers = numbers.filter((num) =&gt; num !== sub);\n        numbers.forEach((num) =&gt; sub -= num);\n        return sub\n    }\n    if (oper === '*') {\n        let mult = 1;\n        numbers.forEach((num) =&gt; mult *= num);\n        return mult;\n    }\n    if (oper === '/') {\n        let div = numbers.shift();\n        numbers.forEach((num) =&gt; div /= num);\n        return div;\n    }\n}\nconsole.log(calc('+', 1, 2, 3, 4));  // 10\nconsole.log(calc('-', 12, 3, 34));  // 19\nconsole.log(calc('*', 2, 3, 4, 5));  // 120\nconsole.log(calc('/', 20, 2, 4));  // 2.5\n</code></pre>"},{"location":"fun%C3%A7%C3%B5es/resursive-function/","title":"Fun\u00e7\u00f5es recursivas","text":"<p>\u00c9 uma fun\u00e7\u00e3o que chama a si mesma para realizar uma tarefa. Em termos mais  simples, \u00e9 um conceito onde uma fun\u00e7\u00e3o \u00e9 definida em termos de si mesma. Isso  \u00e9 comum em programa\u00e7\u00e3o, pois permite a implementa\u00e7\u00e3o de algoritmos complexos  de forma mais elegante e concisa.</p> <p>Aqui est\u00e1 um exemplo simples de uma fun\u00e7\u00e3o recursiva em JavaScript que calcula  o fatorial de um n\u00famero:</p> <pre><code>function fatorial(n) {\n  if (n &gt; 10) return;  // \u00e9 importande determinar quando ocorrer\u00e1 a sa\u00edda\n  if (n === 0) {\n    return 1;\n  } else {\n    return n * fatorial(n - 1);\n  }\n}\n\nconsole.log(fatorial(5));  // 120\n</code></pre> <p>Neste exemplo, a fun\u00e7\u00e3o <code>fatorial</code> \u00e9 definida em termos de si mesma, onde ela  calcula o fatorial de um n\u00famero <code>n</code> multiplicando <code>n</code> pelo fatorial de <code>n - 1</code>.  A recurs\u00e3o continua at\u00e9 que <code>n</code> seja igual a zero, momento em que a fun\u00e7\u00e3o  retorna 1 (o caso base). Essa fun\u00e7\u00e3o recursiva \u00e9 uma implementa\u00e7\u00e3o cl\u00e1ssica de  como calcular o fatorial de um n\u00famero.</p> <p>No entanto, \u00e9 importante ter cuidado ao usar fun\u00e7\u00f5es recursivas, pois elas  podem levar a estouro de pilha (stack overflow) se n\u00e3o houver um caso base  adequado ou se a recurs\u00e3o for muito profunda. Certifique-se sempre de definir  um caso base e garantir que a recurs\u00e3o tenha uma condi\u00e7\u00e3o de parada para  evitar problemas de desempenho.</p>"}]}