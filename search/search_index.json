{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Resolvi fazer esta documenta\u00e7\u00e3o para ir registrando o meu aprendizado de <code>JavaScript</code>.</p>"},{"location":"basico/if-else/","title":"If - Else","text":"<p>O <code>if-else</code> \u00e9 uma estrutura de controle de fluxo que permite executar  diferentes blocos de c\u00f3digo com base em uma condi\u00e7\u00e3o. A estrutura b\u00e1sica do  <code>if-else</code> \u00e9 a seguinte:</p> <pre><code>if (condi\u00e7\u00e3o) {\n    // Este bloco de c\u00f3digo \u00e9 executado se a condi\u00e7\u00e3o for verdadeira\n} else {\n    // Este bloco de c\u00f3digo \u00e9 executado se a condi\u00e7\u00e3o for falsa\n}\n</code></pre> <p>Aqui est\u00e1 como funciona o <code>if-else</code>:</p> <ol> <li> <p>A condi\u00e7\u00e3o \u00e9 avaliada: A express\u00e3o dentro dos par\u00eanteses ap\u00f3s a  palavra-chave <code>if</code> \u00e9 avaliada. Se essa express\u00e3o retornar <code>true</code>, o bloco de  c\u00f3digo dentro das chaves seguintes \u00e9 executado. Se a express\u00e3o for <code>false</code>, o  c\u00f3digo dentro do bloco <code>else</code> (se houver) \u00e9 executado.</p> </li> <li> <p>Execu\u00e7\u00e3o do bloco: O bloco de c\u00f3digo dentro das chaves do bloco <code>if</code> ou  <code>else</code> \u00e9 executado de acordo com o resultado da avalia\u00e7\u00e3o da condi\u00e7\u00e3o.</p> </li> </ol> <p>Aqui est\u00e1 um exemplo simples:</p> <pre><code>let idade = 18;\n\nif (idade &gt;= 18) {\n    console.log(\"Voc\u00ea \u00e9 maior de idade.\");\n} else {\n    console.log(\"Voc\u00ea \u00e9 menor de idade.\");\n}\n\n// Voc\u00ea \u00e9 maior de idade.\n</code></pre> <p>Neste exemplo, a condi\u00e7\u00e3o <code>idade &gt;= 18</code> \u00e9 avaliada. Se for verdadeira, a  mensagem \"Voc\u00ea \u00e9 maior de idade.\" ser\u00e1 impressa; caso contr\u00e1rio, a mensagem  \"Voc\u00ea \u00e9 menor de idade.\" ser\u00e1 impressa.</p> <p>Tamb\u00e9m podemos usar <code>else if</code> para lidar com m\u00faltiplas condi\u00e7\u00f5es. Por exemplo:</p> <pre><code>let nota = 75;\n\nif (nota &gt;= 90) {\n    console.log(\"Aprovado com A.\");\n} else if (nota &gt;= 80) {\n    console.log(\"Aprovado com B.\");\n} else if (nota &gt;= 70) {\n    console.log(\"Aprovado com C.\");\n} else {\n    console.log(\"Reprovado.\");\n}\n\n// Aprovado com B.\n</code></pre> <p>Neste exemplo, o c\u00f3digo verifica a nota do aluno e imprime a mensagem  apropriada com base na nota obtida. Se nenhuma das condi\u00e7\u00f5es for atendida, a  mensagem \"Reprovado.\" ser\u00e1 impressa.</p>"},{"location":"basico/js-html/","title":"Html + JavaScript","text":"<p>Lincamos a nossa p\u00e1gina <code>index.html</code> com o nosso script <code>main.js</code>, atrav\u00e9s do atributo <code>src</code> da tag <code>script</code>:</p> index.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;With HTML&lt;/title&gt;\n  &lt;/head&gt;\n\n  &lt;body&gt;\n    &lt;script src=\"./main.js\"&gt;&lt;/script&gt; &lt;!- aqui n\u00f3s fazemos a jun\u00e7\u00e3o -&gt;\n  &lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre> main.js<pre><code>/**\n * Tudo o que for colocado dentro do 'main.js' \n * ser\u00e1 aplicado no arquivo 'index.html'.\n*/\n\nalert('Os arquivos est\u00e3o lincados!');  // ser\u00e1 mostrada em uma caixa de mensagem\n\nconsole.log('J\u00e1 essa mensagen, aparecer\u00e1 no console do navegador');\n</code></pre>"},{"location":"basico/numbers/","title":"N\u00fameros","text":"<p>Os principais tipos de n\u00fameros em JavaScript s\u00e3o:</p> <p>N\u00fameros inteiros (Integers): Representam n\u00fameros inteiros, positivos ou negativos, sem casas decimais. Exemplos: 42, -10, 0.</p> <p>N\u00fameros de ponto flutuante (Floating-Point Numbers): S\u00e3o usados para representar n\u00fameros com casas decimais. JavaScript usa o padr\u00e3o IEEE 754 para representar n\u00fameros de ponto flutuante de precis\u00e3o dupla. Exemplos: 3.14, -0.5, 1.0.</p> <pre><code>// Alguns exemplos\nlet num1 = 1;\nlet num2 = 2.5;\n\nconsole.log(num1 + num2);  // 3.5\n\n// .toString()\nconsole.log(num1.toString() + num2);  // 12.5 (sting)\n\nlet num3 = 123;\nconsole.log(num3.toString(2));   // 1111011 (bin\u00e1rio)\nconsole.log(num3.toString(8));   // 173 (octal)\nconsole.log(num3.toString(16));  // 7b (hexadecimal)\n\n// .toFixed()\nlet num4 = 23.3566352435\nconsole.log(num4.toFixed(2));  // 23.36\n\n// Number.isIntteger()\nconsole.log(Number.isInteger(num1));  // true\nconsole.log(Number.isInteger(num2));  // false\n\n// Number.isNaN()\nlet temp1 = num2 * 'X';\nlet temp2 = num2 * '10';\nconsole.log(Number.isNaN(temp1));  // true\nconsole.log(Number.isNaN(temp2));  // false\n</code></pre> <p>O javascript usa IEEE 754-2008 para gerenciar os seu c\u00e1lculos.</p> <pre><code>// imprecis\u00f5es\nlet n1 = 0.7;\nlet n2 = 0.1;\n\nconsole.log(n1 + n2);  // 0.7999999999999999 \ud83e\udd14\n\nconsole.log(100 / 0);  // Infinity \ud83e\udd14\n</code></pre>"},{"location":"basico/objects/","title":"Objetos","text":"<p><code>Objects</code>  s\u00e3o estruturas de dados que pode armazenar valores e fun\u00e7\u00f5es  relacionados. Os objetos s\u00e3o uma parte fundamental da linguagem e s\u00e3o usados  para representar e organizar informa\u00e7\u00f5es de maneira eficaz. Eles s\u00e3o  constru\u00eddos a partir de pares de chave-valor, nos quais as chaves s\u00e3o <code>strings</code>  (ou <code>symbols</code>) que atuam como identificadores e os valores podem ser de  qualquer tipo de dado, incluindo <code>numbers</code>, <code>strings</code>, outros <code>objects</code>,  <code>functions</code> e assim por diante.</p> <p>Vejamos um exemplo de objeto: <pre><code>var pessoa = {\n  nome: \"Jo\u00e3o\",\n  idade: 30,\n  profissao: \"Desenvolvedor\"\n};\n</code></pre></p> <p>Neste exemplo, <code>pessoa</code> \u00e9 um objeto com tr\u00eas propriedades: <code>nome</code>, <code>idade</code> e  <code>profissao</code>, e cada propriedade tem um valor associado a ela.</p> <p>Voc\u00ea pode acessar as propriedades de um objeto usando a nota\u00e7\u00e3o de ponto ou a  nota\u00e7\u00e3o de colchetes, assim:</p> <pre><code>console.log(pessoa.nome);      // Jo\u00e3o\nconsole.log(pessoa['idade']);  // 30\n</code></pre> <p>Al\u00e9m disso, voc\u00ea pode adicionar novas propriedades, modificar propriedades  existentes e at\u00e9 mesmo remover propriedades de objetos em JavaScript. Objetos  tamb\u00e9m podem conter <code>methods</code>, que s\u00e3o <code>functions</code> associadas a eles. Eles s\u00e3o  muito vers\u00e1teis e formam a base da programa\u00e7\u00e3o orientada a objetos em  JavaScript.</p>"},{"location":"basico/operators/","title":"Operadores","text":"<p>Em javascript n\u00f3s temos operadores aritim\u00e9ticos, de incremento e de atribui\u00e7\u00e3o</p>"},{"location":"basico/operators/#aritimeticos","title":"Aritim\u00e9ticos","text":"<p>adi\u00e7\u00e3o / concatena\u00e7\u00e3o (+) <pre><code>console.log(2 + 3);      // 5\nconsole.log('b' + 'a');  // ba\nconsole.log('a' + 15);   // a15\n</code></pre></p> <p>subtra\u00e7\u00e3o (-) <pre><code>console.log(10 - 3);     // 7\n</code></pre></p> <p>multiplica\u00e7\u00e3o (*) <pre><code>console.log(5 * 5);      // 25\n</code></pre></p> <p>divis\u00e3o (/) <pre><code>console.log(15 / 3);     // 5\n</code></pre></p> <p>potencia\u00e7\u00e3o (**) <pre><code>console.log(2 ** 3);     // 8\n</code></pre></p> <p>m\u00f3dulo da divis\u00e3o (%) <pre><code>console.log(18 / 5)      // 3\n</code></pre></p> <p>A preced\u00eancia de operadores \u00e9 a seguinte:</p> 1. (\u2026) o que estiver dentro dos parentesis 2. ** o que for potencia\u00e7\u00e3o 3. *   /   % multiplica\u00e7\u00e3o, divis\u00e3o e m\u00f3dulo da divis\u00e3o 4. +   - adi\u00e7\u00e3o e subtra\u00e7\u00e3o"},{"location":"basico/operators/#incremento","title":"Incremento (++)","text":"<p>Cada vez que \u00e9 usado, incrementa (ou decrementa) 1 do valor da vari\u00e1vel pode ser usado antes ou depois da vari\u00e1vel.</p> <pre><code>let num = 1;\nconsole.log(num++);  // imprime 1 e atualiza o valor de num para 2\nconsole.log(num);    // 2\nconsole.log(++num);  // atualiza o valor de num para 3 e imprime 3\nconsole.log(num);    // 3\n</code></pre>"},{"location":"basico/operators/#decremento-","title":"Decremento (- -)","text":"<pre><code>console.log(num--);  // imprime 3 e atualiza o valor de num para 2\nconsole.log(num);    // 2\nconsole.log(--num);  // atualiza o valor de num para 1 e imprime 1\nconsole.log(num);    // 1\n</code></pre>"},{"location":"basico/operators/#atribuicao","title":"Atribui\u00e7\u00e3o","text":"<pre><code>// += \nconsole.log(num += 10); // num = num + 10 -&gt; 11\n// -=\nconsole.log(num -= 2);  // num = num -  2 -&gt;  9\n// *=\nconsole.log(num *= 2);  // num = num *  2 -&gt; 18\n// /=\nconsole.log(num /= 3);  // num = num /  3 -&gt;  6\n// **=\nconsole.log(num **= 2); // num = num ** 2 -&gt; 36\n</code></pre>"},{"location":"basico/operators/#comparacao","title":"Compara\u00e7\u00e3o","text":""},{"location":"basico/operators/#maior-que","title":"maior que ( &gt; )","text":"<pre><code>console.log(10 &gt; 5);   // true\nconsole.log(10 &gt; 10);  // false\nconsole.log(10 &gt; 11);  // false\n</code></pre>"},{"location":"basico/operators/#maior-igual-a","title":"maior igual a ( &gt;= )","text":"<pre><code>console.log(10 &gt;= 5);   // true\nconsole.log(10 &gt;= 10);  // true\nconsole.log(10 &gt;= 11);  // false\n</code></pre>"},{"location":"basico/operators/#menor-que","title":"menor que ( &lt; )","text":"<pre><code>console.log(10 &lt; 5);   // false\nconsole.log(10 &lt; 10);  // false\nconsole.log(10 &lt; 11);  // true\n</code></pre>"},{"location":"basico/operators/#menor-igual-a","title":"menor igual a ( &lt;= )","text":"<pre><code>console.log(10 &lt;= 5);   // false\nconsole.log(10 &lt;= 10);  // true\nconsole.log(10 &lt;= 11);  // true\n</code></pre>"},{"location":"basico/operators/#igual-a","title":"igual a ( == )","text":"<p>checa ap\u00e9nas o valor (evitar o uso)</p> <pre><code>console.log(10 == 5);     // false\nconsole.log(10 == 10);    // true\nconsole.log(10 == '10');  // true (por coer\u00e7\u00e3o de tipos)\n</code></pre>"},{"location":"basico/operators/#diferente-de","title":"diferente de ( != )","text":"<p>checa ap\u00e9nas o valor (evitar o uso)</p> <pre><code>console.log(10 != 5);     // true\nconsole.log(10 != 10);    // false\nconsole.log(10 != '10');  // false (por coer\u00e7\u00e3o de tipos)\n</code></pre>"},{"location":"basico/operators/#estritamente-igual-a","title":"estritamente igual a ( === )","text":"<p>checa valor e tipo</p> <pre><code>console.log(10 === 5);     // false\nconsole.log(10 === 10);    // true\nconsole.log(10 === '10');  // false\n</code></pre>"},{"location":"basico/operators/#estritamente-diferente-de","title":"estritamente diferente de ( !== )","text":"<p>checa valor e tipo</p> <pre><code>console.log(10 !== 5);     // true\nconsole.log(10 !== 10);    // false\nconsole.log(10 !== '10');  // true\n</code></pre>"},{"location":"basico/operators/#logicos","title":"L\u00f3gicos","text":""},{"location":"basico/operators/#and","title":"And ( &amp;&amp; )","text":"<pre><code>console.log(true &amp;&amp; true);    // true\nconsole.log(true &amp;&amp; false);   // false\nconsole.log(false &amp;&amp; true);   // false\nconsole.log(false &amp;&amp; false);  // false\n</code></pre>"},{"location":"basico/operators/#or","title":"Or ( || )","text":"<pre><code>console.log(true || true);    // true\nconsole.log(true || false);   // true\nconsole.log(false || true);   // treu\nconsole.log(false || false);  // false\n</code></pre>"},{"location":"basico/operators/#not","title":"Not ( ! )","text":"<pre><code>console.log(!true);           // false\nconsole.log(!false);          // true\n</code></pre>"},{"location":"basico/short-circuit/","title":"Short Circuit (curto circuito)","text":"<p>Um \"short circuit\" refere-se a uma t\u00e9cnica de avalia\u00e7\u00e3o de express\u00f5es l\u00f3gicas  que pode ser usada para determinar rapidamente o resultado de uma express\u00e3o com  base na primeira parte avaliada. Isso \u00e9 particularmente \u00fatil em express\u00f5es  l\u00f3gicas compostas, como aquelas envolvendo operadores l\u00f3gicos <code>&amp;&amp;</code> (E l\u00f3gico) e  <code>||</code> (OU l\u00f3gico).</p> <p>Existem dois tipos principais de \"short circuit\" em JavaScript:</p>"},{"location":"basico/short-circuit/#operador-and","title":"Operador And ( &amp;&amp; )","text":"<p>Quando voc\u00ea usa o operador <code>&amp;&amp;</code>, a express\u00e3o \u00e9 avaliada da esquerda para  a direita. Se a primeira parte (\u00e0 esquerda) da express\u00e3o for avaliada como  falsa, a segunda parte (\u00e0 direita) n\u00e3o ser\u00e1 avaliada, economizando recursos.  Isso \u00e9 \u00fatil para express\u00f5es em que todas as partes precisam ser verdadeiras  para que a express\u00e3o seja verdadeira.</p> <p>Exemplo: <pre><code>function sayHello(name) {\n    return `Hello ${name}`;\n}\n\nlet toPrint = '';\nconsole.log(toPrint &amp;&amp; sayHello('Ot\u00e1vio'));  // \n\ntoPrint = 'a';\nconsole.log(toPrint &amp;&amp; sayHello('Sergio'));  //  Sergio\n</code></pre></p>"},{"location":"basico/short-circuit/#operador-or","title":"Operador Or ( || )","text":"<p>Com o operador <code>||</code>, a express\u00e3o \u00e9 novamente avaliada da esquerda para a  direita. No entanto, se a primeira parte (\u00e0 esquerda) for avaliada como  verdadeira, a segunda parte (\u00e0 direita) n\u00e3o ser\u00e1 avaliada, economizando  recursos. Isso \u00e9 \u00fatil quando voc\u00ea deseja fornecer um valor padr\u00e3o se a  primeira parte for falsa.</p> <p>Exemplo: <pre><code>const userColor = 'red';\nconst defaultColor = userColor || 'black';\n\nconsole.log(defaultColor)  // red\n\nuserColor = '';\nconsole.log(defaultColor)  // black\n</code></pre></p>"},{"location":"basico/short-circuit/#conclusao","title":"Conclus\u00e3o","text":"<p>O uso de short circuit \u00e9 uma t\u00e9cnica comum em JavaScript para melhorar a  efici\u00eancia do c\u00f3digo e evitar erros desnecess\u00e1rios, especialmente ao lidar com  condi\u00e7\u00f5es e valores padr\u00e3o. No entanto, \u00e9 importante us\u00e1-lo com cuidado, pois  pode afetar a legibilidade do c\u00f3digo se n\u00e3o for usado de forma apropriada.</p>"},{"location":"basico/strings/","title":"Strings","text":"<p>Em JavaScript, uma <code>string</code> \u00e9 um tipo de dado que representa uma sequ\u00eancia de caracteres.  As strings s\u00e3o usadas para armazenar e manipular texto em JavaScript.  Uma <code>string</code> pode conter letras, n\u00fameros, s\u00edmbolos e espa\u00e7os.</p> <pre><code>// indexa\u00e7\u00e3o\n//          0123456789...\nlet text = \"O rato comeu o Queijo\";\n\nconsole.log(text[4]);   // t\nconsole.log(text[13]);  // o\nconsole.log(text[19]);  // j\nconsole.log(text[21]);  // undefined\nconsole.log(text[-1]);  // undefined\n</code></pre>"},{"location":"basico/strings/#metodos","title":"M\u00e9todos","text":""},{"location":"basico/strings/#charat","title":"charAt","text":"<pre><code>//String.charAt(pos: number): string\nconsole.log(text.charAt(3));   // a  \nconsole.log(text.charAt(21));  // ''\n</code></pre>"},{"location":"basico/strings/#concat","title":"concat","text":"<pre><code>// String.concat(...strings: string[]): string\nconsole.log(text.concat('!'));  // O rato comeu o queijo!\n</code></pre>"},{"location":"basico/strings/#indexof","title":"indexOf","text":"<pre><code>// String.indexOf(searchString: string, position?: number | undefined): number\nconsole.log(text.indexOf('comeu'));  // 7  (inicia na posi\u00e7\u00e3o 7)\nconsole.log(text.indexOf('Comeu'));  // -1 (nada foi encontrado)\n</code></pre>"},{"location":"basico/strings/#lastindexof","title":"lastIndexOf","text":"<pre><code>// String.lastIndexOf(searchString: string, position?: number | undefined): number\nconsole.log(text.lastIndexOf('o'));  // 20 (mostra a \u00faltima ocorr\u00eancia)\n</code></pre>"},{"location":"basico/strings/#match","title":"match","text":"<pre><code>// Regular Expression\nconsole.log(text.match(/[A-Z]/));  // ['O', index: 0, input: 'O rato... ] \nconsole.log(text.match(/[A-Z]/g));  // ['O', 'Q'] \n</code></pre>"},{"location":"basico/strings/#search","title":"search","text":"<pre><code>// Regular Expression\nconsole.log(text.search(/o/));  // 5 (primeira ocorr\u00eancia)\n</code></pre>"},{"location":"basico/strings/#replace","title":"replace","text":"<pre><code>// Regular Expression\nconsole.log(text.replace('o', '#'));   // O rat# comeu o Queijo\nconsole.log(text.replace(/o/, '#'));   // O rat# comeu o Queijo\nconsole.log(text.replace(/o/g, '#'));  // O rat# c#meu # Queij#\n</code></pre>"},{"location":"basico/strings/#length","title":"length","text":"<pre><code>console.log(text.length);  // 21 (do 0 ao 20)\n</code></pre>"},{"location":"basico/strings/#slice","title":"slice","text":"<pre><code>// String.slice(start?: number | undefined, end?: number | undefined): string\nconsole.log(text.slice(7, 11 + 1));  // comeu\nconsole.log(text.slice(-6));         // Queijo\nconsole.log(text.slice(-6, -3));     // Que\n</code></pre>"},{"location":"basico/strings/#split","title":"split","text":"<pre><code>console.log(text.split(' '));  // [ 'O', 'rato', 'comeu', 'o', 'Queijo' ]\nconsole.log(text.split(' ', 2));  // [ 'O', 'rato' ]\n</code></pre>"},{"location":"basico/strings/#touppercase","title":"toUpperCase","text":"<pre><code>console.log(text.toUpperCase());  // O RATO COMEU O QUEIJO\n</code></pre>"},{"location":"basico/strings/#tolowercase","title":"toLowerCase","text":"<pre><code>console.log(text.toLowerCase());  // o rato comeu o queijo\n</code></pre>"},{"location":"basico/switch-case/","title":"Switch - Case","text":"<p>O <code>switch - case</code> \u00e9 uma estrutura de controle de decis\u00e3o em JavaScript que \u00e9 usada  para avaliar uma express\u00e3o e executar c\u00f3digo com base no valor dessa express\u00e3o.  \u00c9 frequentemente usado para substituir m\u00faltiplas instru\u00e7\u00f5es <code>if-else</code> quando  voc\u00ea precisa fazer diferentes a\u00e7\u00f5es com base em um valor espec\u00edfico. A  estrutura geral do <code>switch - case</code> \u00e9 a seguinte:</p> <pre><code>switch (expressao) {\n  case valor1:\n    // C\u00f3digo a ser executado se a express\u00e3o for igual a valor1\n    break;\n  case valor2:\n    // C\u00f3digo a ser executado se a express\u00e3o for igual a valor2\n    break;\n  // ... Mais casos\n  default:\n    // C\u00f3digo a ser executado se nenhum dos casos anteriores for correspondido\n}\n</code></pre> <p>O <code>switch - case</code> funciona da seguinte maneira:</p> <ol> <li>A express\u00e3o \u00e9 avaliada uma vez.</li> <li>O valor resultante da express\u00e3o \u00e9 comparado com cada caso (valor1, valor2,  etc.) na ordem em que eles s\u00e3o listados. </li> <li>Quando uma correspond\u00eancia \u00e9 encontrada, o c\u00f3digo dentro desse caso \u00e9  executado.</li> <li>A instru\u00e7\u00e3o <code>break</code> \u00e9 usada para sair do <code>switch - case</code> ap\u00f3s a execu\u00e7\u00e3o do  c\u00f3digo do caso correspondente. Isso evita que os casos subsequentes sejam  executados acidentalmente. No entanto, o <code>break</code> n\u00e3o \u00e9 estritamente necess\u00e1rio;  se voc\u00ea omiti-lo, o c\u00f3digo continuar\u00e1 sendo executado nos casos subsequentes  at\u00e9 encontrar um <code>break</code> ou atingir o final do <code>switch - case</code>.</li> <li>Se nenhum caso corresponder ao valor da express\u00e3o, o c\u00f3digo dentro do bloco  <code>default</code> \u00e9 executado (se houver um bloco <code>default</code>). O bloco <code>default</code> \u00e9  opcional.</li> </ol>"},{"location":"basico/switch-case/#exemplo","title":"Exemplo","text":"<pre><code>const date = new Date(2023, 2, 22);\nlet dayOfWeekStr;\n\nswitch (date.getDay()) {\n    case 0:\n        dayOfWeekStr = 'domingo';\n        break;\n    case 1:\n        dayOfWeekStr = 'segunda-feira';\n        break;\n    case 2:\n        dayOfWeekStr = 'ter\u00e7a-feira';\n        break;\n    case 3:\n        dayOfWeekStr = 'quarta-feira';\n        break;\n    case 4:\n        dayOfWeekStr = 'quinta-feira';\n        break;\n    case 5:\n        dayOfWeekStr = 'sexta-feira';\n        break;\n    case 6:\n        dayOfWeekStr = 's\u00e1bado';\n        break;\n    default:\n        dayOfWeekStr = 'dia normal'\n        break;\n}\n\nconst localDate = date.toLocaleString('pt-BR', { timeZone: 'UTC' }).split(',')\nconsole.log(`Dia ${localDate[0]} foi ${dayOfWeekStr}.`);\n\n// Dia 22/03/2023 foi quarta-feira.\n</code></pre>"},{"location":"basico/ternary-operator/","title":"Operador Tern\u00e1rio","text":"<p>Um operador tern\u00e1rio \u00e9 um operador condicional que permite avaliar uma  express\u00e3o e retornar um valor com base em uma condi\u00e7\u00e3o. Ele \u00e9 chamado de  \"tern\u00e1rio\" porque envolve tr\u00eas operandos: a condi\u00e7\u00e3o a ser testada, o valor a  ser retornado se a condi\u00e7\u00e3o for verdadeira e o valor a ser retornado se a  condi\u00e7\u00e3o for falsa.</p> <p>A sintaxe b\u00e1sica do operador tern\u00e1rio \u00e9 a seguinte:</p> <pre><code>condi\u00e7\u00e3o ? valor_se_verdadeiro : valor_se_falso;\n</code></pre> <p>Funciona assim:</p> <ol> <li>A condi\u00e7\u00e3o \u00e9 avaliada primeiro.</li> <li>Se a condi\u00e7\u00e3o for verdadeira, o valor ap\u00f3s o ponto de interroga\u00e7\u00e3o (<code>?</code>)  \u00e9 retornado.</li> <li>Se a condi\u00e7\u00e3o for falsa, o valor ap\u00f3s os dois pontos (<code>:</code>) \u00e9 retornado.</li> </ol> <p>Exemplo:</p> <pre><code>var idade = 20;\nvar mensagem = idade &gt;= 18 ? \"Maior de idade\" : \"Menor de idade\";\n\nconsole.log(mensagem);  // O resultado ser\u00e1 \"Maior de idade\" neste caso.\n</code></pre> <p>Neste exemplo, a condi\u00e7\u00e3o <code>idade &gt;= 18</code> \u00e9 avaliada. Se for verdadeira, a string  \"Maior de idade\" \u00e9 atribu\u00edda \u00e0 vari\u00e1vel <code>mensagem</code>. Caso contr\u00e1rio, a string  \"Menor de idade\" \u00e9 atribu\u00edda.</p> <p>O operador tern\u00e1rio \u00e9 uma maneira concisa de escrever express\u00f5es condicionais  em JavaScript e pode ser \u00fatil em muitas situa\u00e7\u00f5es, como na atribui\u00e7\u00e3o de  valores com base em condi\u00e7\u00f5es simples.</p>"},{"location":"basico/values/","title":"Valores e Tipos","text":""},{"location":"basico/values/#primitivos","title":"Primitivos","text":"<p>Os valores primitivos s\u00e3o imut\u00e1veis:</p> <ul> <li>string </li> <li>number </li> <li>boolean</li> <li>undefined</li> <li>null</li> <li>bigint</li> <li>symbol</li> </ul> <p>Sempre que os atribu\u00edmos \u00e0 outra vari\u00e1veis, seus valores s\u00e3o copiados </p> <pre><code>let a = 12;\nlet b = a;  // o valor 12 \u00e9 copiado para b\nconsole.log(a, b);  // 12 12\nb = 17;\nconsole.log(a, b);  // 12 17\n</code></pre>"},{"location":"basico/values/#referencia","title":"Refer\u00eancia","text":"<p>Os valores de refer\u00eancia s\u00e3o mut\u00e1veis:</p> <ul> <li>array</li> <li>object</li> <li>function</li> </ul> <p>Sempre que os atribu\u00edmos \u00e0 outra vari\u00e1vel, a nova vari\u00e1vel aponta para o mesmo endere\u00e7o na mem\u00f3ria</p> <pre><code>const c = [1, 2, 3];\nconst d = c;  // a vari\u00e1vel d aponta para o mesmo endere\u00e7o de mem\u00f3ria que c\n\nconsole.log(c, d);  // [1, 2, 3] [1, 2, 3]\nd.push(4);\nconsole.log(c, d);  // [1, 2, 3, 4] [1, 2, 3, 4]\n\n\n// para fazer uma c\u00f3pia, podemos usar o spread operator `...`\nconst e = [...d]\n\nconsole.log(d, e);  // [1, 2, 3, 4] [1, 2, 3, 4]\ne.pop();\nconsole.log(d, e);  // [1, 2, 3, 4] [1, 2, 3]\n\n\n// mesmo exemplo com object\nconst f = { name: 'Cesar', age: 53 }\nconst g = { ...f }\n\nf.name = 'Jady'\nconsole.log(f, g);\n</code></pre>"},{"location":"basico/values/#tipos","title":"Tipos","text":""},{"location":"basico/values/#strings","title":"strings","text":"<pre><code>const firstName = \"Cesar\";\nconst lastName = 'Godoi';\nconst cityOfBirth = `Bauru`;\n</code></pre>"},{"location":"basico/values/#numbers","title":"numbers","text":"<pre><code>const integer = 12;\nconst float = 12.34;\n</code></pre>"},{"location":"basico/values/#undefined","title":"undefined","text":"<pre><code>let country;\nvar district;\n</code></pre>"},{"location":"basico/values/#null","title":"null","text":"<pre><code>const dog = null;\n</code></pre>"},{"location":"basico/values/#boolean","title":"boolean","text":"<pre><code>const exist = true;\nconst doesNotExist = false;\n</code></pre>"},{"location":"basico/values/#symbol","title":"symbol","text":"<pre><code>const symbl = Symbol('\u00e9 nois');\n</code></pre>"},{"location":"basico/values/#typeof","title":"typeof","text":"<p>Podemos usar o m\u00e9todo <code>typeof</code> para descobrir o tipo de uma vari\u00e1vel ou constante. <pre><code>console.log(`${cityOfBirth} = ${typeof cityOfBirth}`);\nconsole.log(`${float} = ${typeof float}`);\nconsole.log(`${country} = ${typeof country}`);\nconsole.log(`${dog} = ${typeof dog}`);  // o typeof de null ser\u00e1 object (bug do javascript)\nconsole.log(`${doesNotExist} = ${typeof doesNotExist}`);\nconsole.log(`${typeof symbl} descr: ${symbl.description}`);\n</code></pre></p>"},{"location":"basico/variables/","title":"Vari\u00e1veis e Constantes","text":""},{"location":"basico/variables/#let-e-var","title":"let e var","text":"<p>Em javascript podemos usar <code>let</code> e <code>var</code> para declarar vari\u00e1veis. No entanto devemos dar prefer\u00eancia ao <code>let</code>, pois \u00e9 mais moderna (ECMAScript 2015 - ES6).   </p> <p><code>let</code> tem escopo de bloco   <code>var</code>  tem escopo de fun\u00e7\u00e3o</p> <p>Regra Geral e boas pr\u00e1ticas para se nomear vari\u00e1veis no javascript:  </p> <ul> <li>Vari\u00e1veis s\u00e3o case-sensitive (diferencia mai\u00fasculas de min\u00fasculas);   </li> <li>N\u00e3o podemos criar vari\u00e1veis com palavras reservadas do javascript;   </li> <li>N\u00e3o podemos usar espa\u00e7os ' ' ou hifen '-';   </li> <li>N\u00e3o podemos come\u00e7ar o nome da vari\u00e1vel com n\u00fameros;   </li> <li>Vari\u00e1veis precisam ter nomes significativos   </li> <li>Utilizamos nota\u00e7\u00e3o camelCase</li> <li>N\u00e3o podemos redeclarar vari\u00e1veis com <code>let</code></li> <li>Sempre d\u00ea prefer\u00eancia em usar <code>let</code> ao inv\u00e9s de <code>var</code> </li> </ul> <pre><code>let name;  // vari\u00e1vel declarada sem nenhum valor atribuido \nconsole.log(name);  // returns undefined\n\nname = \"Maria Eneida\";\nconsole.log(name);  // retorna Maria Eneida\n\nlet otherName = \"Cesar Godoi\";  // vari\u00e1vel declarada com valor atribuido\nconsole.log(otherName);  // returno Cesar Godoi\n\n\nvar cidade = \"S\u00e3o Paulo\";  // vari\u00e1vel declarada com valor atribu\u00eddo\nconsole.log(cidade);  // retorna S\u00e3o Paulo\n\nvar cidade = \"Bauru\";  // 'var' pode ser re-declarada sem provocar erro\nconsole.log(cidade);  // retorna Bauru\n</code></pre>"},{"location":"basico/variables/#const","title":"const","text":"<p>Em javascript n\u00f3s usamos <code>const</code> para declarar constantes.</p> <p>No que diz respeito \u00e0s regras e boas pr\u00e1ticas na nomea\u00e7\u00e3o de constantes,  podemos dizer que al\u00e9m das descritas para <code>let</code> e <code>var</code>, temos as seguintes:</p> <ul> <li>Constantes precisam ser atribu\u00eddas com um valor ao serem declaradas;</li> <li>N\u00e3o podemos redeclarar constantes com <code>constant</code>;</li> <li>Sempre d\u00ea prefer\u00eancia em usar <code>const</code> ao inv\u00e9s de <code>let</code> ou <code>var</code> (quando poss\u00edvel);</li> </ul> <pre><code>const pi = 3.14;\nconsole.log(pi);  // retorna 3.14\n</code></pre>"},{"location":"basico/Loops/break-continue/","title":"Break - Continue","text":"<p>O <code>break</code> e <code>continue</code> s\u00e3o palavras-chave que permitem controlar o fluxo de  execu\u00e7\u00e3o em loops, como <code>for</code>, <code>while</code> e <code>do...while</code>. Vou explicar como cada  um deles funciona:</p>"},{"location":"basico/Loops/break-continue/#break","title":"Break","text":"<p>O <code>break</code> \u00e9 usado para sair imediatamente de um loop quando uma determinada  condi\u00e7\u00e3o \u00e9 atendida. Quando o <code>break</code> \u00e9 executado dentro de um loop, o loop \u00e9  encerrado e a execu\u00e7\u00e3o continua ap\u00f3s o loop. Aqui est\u00e1 um exemplo:</p> <pre><code>for (let i = 0; i &lt; 5; i++) {\n    if (i === 3) {\n        break; // Sai do loop quando i for igual a 3\n    }\n    console.log(i);\n}\n\n// 0\n// 1\n// 2\n</code></pre>"},{"location":"basico/Loops/break-continue/#continue","title":"Continue","text":"<p>O <code>continue</code> \u00e9 usado para pular a itera\u00e7\u00e3o atual de um loop e avan\u00e7ar para a  pr\u00f3xima itera\u00e7\u00e3o. Quando o <code>continue</code> \u00e9 executado dentro de um loop, o c\u00f3digo  restante dentro da itera\u00e7\u00e3o atual \u00e9 ignorado, e a execu\u00e7\u00e3o continua com a  pr\u00f3xima itera\u00e7\u00e3o do loop. Aqui est\u00e1 um exemplo:</p> <pre><code>for (let i = 0; i &lt; 5; i++) {\n    if (i === 2) {\n        continue; // Pula a itera\u00e7\u00e3o quando i for igual a 2\n    }\n    console.log(i);\n}\n\n// 0\n// 1\n// 3\n// 4\n</code></pre> <p>O <code>break</code> e o <code>continue</code> s\u00e3o \u00fateis para controlar o comportamento de loops em  JavaScript, permitindo que voc\u00ea saia de um loop prematuramente ou pule  itera\u00e7\u00f5es espec\u00edficas, de acordo com as condi\u00e7\u00f5es definidas no c\u00f3digo.  Certifique-se de us\u00e1-los com cuidado para evitar loops infinitos ou  comportamentos inesperados em seu c\u00f3digo.</p>"},{"location":"basico/Loops/do-while/","title":"Do...while","text":"<p>O la\u00e7o <code>do...while</code> \u00e9 uma estrutura de controle que permite que um bloco de  c\u00f3digo seja executado repetidamente enquanto uma condi\u00e7\u00e3o especificada for  verdadeira. A principal diferen\u00e7a entre um <code>do...while</code> e um <code>while</code> \u00e9 que no  <code>do...while</code>, o bloco de c\u00f3digo \u00e9 executado pelo menos uma vez, mesmo que a  condi\u00e7\u00e3o seja falsa desde o in\u00edcio.</p> <p>Aqui est\u00e1 a estrutura b\u00e1sica de um <code>do...while</code>:</p> <pre><code>do {\n  // Bloco de c\u00f3digo a ser executado\n} while (condi\u00e7\u00e3o);\n</code></pre> <p>Funciona assim:</p> <ol> <li> <p>O c\u00f3digo dentro do bloco \u00e9 executado pela primeira vez, independentemente  da condi\u00e7\u00e3o.</p> </li> <li> <p>Ap\u00f3s a execu\u00e7\u00e3o do bloco, a condi\u00e7\u00e3o \u00e9 verificada.</p> </li> <li> <p>Se a condi\u00e7\u00e3o for verdadeira, o c\u00f3digo dentro do bloco \u00e9 executado  novamente. Esse processo se repete at\u00e9 que a condi\u00e7\u00e3o se torne falsa.</p> </li> <li> <p>Uma vez que a condi\u00e7\u00e3o se torne falsa, a execu\u00e7\u00e3o do c\u00f3digo no <code>do...while</code>  \u00e9 interrompida, e o programa continua com as instru\u00e7\u00f5es ap\u00f3s o <code>do...while</code>.</p> </li> </ol> <p>Aqui est\u00e1 um exemplo simples de uso do <code>do...while</code> em JavaScript:</p> <pre><code>let contador = 0;\n\ndo {\n  console.log(\"Contador: \" + contador);\n  contador++;\n} while (contador &lt; 5);\n\n// Contador: 0\n// Contador: 1\n// Contador: 2\n// Contador: 3\n// Contador: 4\n</code></pre> <p>Neste exemplo, o bloco de c\u00f3digo dentro do <code>do...while</code> \u00e9 executado pelo menos  uma vez, e depois ele continua a ser executado enquanto a condi\u00e7\u00e3o  <code>contador &lt; 5</code> for verdadeira.</p> <p>Mesmo que a condi\u00e7\u00e3o seja falsa desde o in\u00edcio, o bloco de c\u00f3digo ainda \u00e9  executado pelo menos uma vez antes que a condi\u00e7\u00e3o seja verificada. Isso faz do  <code>do...while</code> uma boa escolha quando voc\u00ea precisa garantir que um bloco de  c\u00f3digo seja executado pelo menos uma vez, independentemente da condi\u00e7\u00e3o.</p>"},{"location":"basico/Loops/for-each/","title":"forEach()","text":"<p>O m\u00e9todo <code>forEach()</code> \u00e9 uma maneira de iterar sobre elementos de um array e  executar uma fun\u00e7\u00e3o para cada elemento, sem a necessidade de usar um loop <code>for</code>  ou <code>while</code>. O <code>forEach()</code> \u00e9 uma alternativa mais concisa e leg\u00edvel para  percorrer arrays, especialmente quando voc\u00ea deseja realizar uma opera\u00e7\u00e3o em  cada item do array.</p> <p>Aqui est\u00e1 a sintaxe b\u00e1sica do <code>forEach()</code>:</p> <pre><code>array.forEach(function(element, index, array) {\n  // C\u00f3digo a ser executado para cada elemento do array\n});\n</code></pre> <ul> <li><code>array</code>: O array que voc\u00ea deseja iterar.</li> <li><code>element</code>: O elemento atual do array na itera\u00e7\u00e3o.</li> <li><code>index</code>: O \u00edndice do elemento atual no array.</li> <li><code>array</code>: O pr\u00f3prio array sendo percorrido.</li> </ul> <p>A fun\u00e7\u00e3o passada como argumento para <code>forEach()</code> \u00e9 executada uma vez para cada  elemento no array. Voc\u00ea pode nomear os par\u00e2metros da fun\u00e7\u00e3o como quiser, mas \u00e9  comum usar <code>element</code>, <code>index</code> e <code>array</code> para maior clareza.</p> <p>Aqui est\u00e1 um exemplo simples de como usar <code>forEach()</code>:</p> <pre><code>const numbers = [1, 2, 3, 4, 5];\n\nnumbers.forEach((number, index) =&gt; {\n  console.log(`Elemento ${number} no \u00edndice ${index}`);\n});\n\n// Elemento 1 no \u00edndice 0\n// Elemento 2 no \u00edndice 1\n// Elemento 3 no \u00edndice 2\n// Elemento 4 no \u00edndice 3\n// Elemento 5 no \u00edndice 4\n</code></pre> <p>Este c\u00f3digo ir\u00e1 percorrer o array <code>numbers</code> e imprimir uma mensagem para cada  elemento, exibindo o n\u00famero e o \u00edndice correspondente.</p> <p>O m\u00e9todo <code>forEach()</code> \u00e9 \u00fatil quando voc\u00ea deseja realizar uma a\u00e7\u00e3o para cada  elemento do array, como executar uma fun\u00e7\u00e3o em cada um deles, atualizar os  valores, ou realizar qualquer opera\u00e7\u00e3o desejada sem a necessidade de escrever  manualmente um loop <code>for</code>. </p> <p>No entanto, lembre-se de que o <code>forEach()</code> n\u00e3o \u00e9 a melhor escolha se voc\u00ea  precisar interromper o loop antes de atingir o final do array ou se precisar  criar um novo array com base nos elementos do array original; nesses casos, um  loop <code>for</code> tradicional ou outros m\u00e9todos como <code>map()</code>, <code>filter()</code>, e <code>reduce()</code>  podem ser mais adequados.</p>"},{"location":"basico/Loops/for-in/","title":"For...in","text":"<p>Os la\u00e7os <code>for...in</code> em JavaScript s\u00e3o usados para iterar sobre as propriedades  enumer\u00e1veis de um <code>objeto</code>. Eles permitem percorrer os nomes de propriedades de  um objeto, em oposi\u00e7\u00e3o \u00e0 itera\u00e7\u00e3o sobre os valores dessas propriedades.  Aqui est\u00e1 a estrutura b\u00e1sica de um la\u00e7o <code>for...in</code>:</p> <pre><code>for (let propriedade in objeto) {\n  // c\u00f3digo a ser executado para cada propriedade\n}\n</code></pre> <p>Funciona assim:</p> <ol> <li><code>for</code>: A palavra-chave <code>for</code> \u00e9 usada para iniciar o loop.</li> <li><code>(let propriedade in objeto)</code>: A express\u00e3o entre par\u00eanteses especifica tr\u00eas  partes:</li> <li><code>let propriedade</code>: Isso cria uma vari\u00e1vel chamada \"propriedade\" que ser\u00e1     usada para armazenar o nome de cada propriedade do objeto enquanto iteramos     sobre ele.</li> <li><code>in</code>: \u00c9 o operador que define a rela\u00e7\u00e3o entre a vari\u00e1vel \"propriedade\" e o     objeto que estamos iterando.</li> <li> <p><code>objeto</code>: Este \u00e9 o objeto sobre o qual voc\u00ea deseja iterar.</p> </li> <li> <p><code>{}</code>: O bloco de c\u00f3digo dentro das chaves <code>{}</code> cont\u00e9m as instru\u00e7\u00f5es a serem  executadas para cada propriedade do objeto.</p> </li> </ol> <p>A cada itera\u00e7\u00e3o do loop, a vari\u00e1vel \"propriedade\" conter\u00e1 o nome da propriedade  do objeto, e voc\u00ea pode acessar o valor correspondente usando a nota\u00e7\u00e3o de  colchetes <code>objeto[propriedade]</code>.</p> <p>Aqui est\u00e1 um exemplo simples:</p> <pre><code>var pessoa = {\n  nome: \"Jo\u00e3o\",\n  idade: 30,\n  cidade: \"S\u00e3o Paulo\"\n};\n\nfor (var prop in pessoa) {\n  console.log(prop + \": \" + pessoa[prop]);\n}\n\n// nome: Jo\u00e3o\n// idade: 30\n// cidade: S\u00e3o Paulo\n</code></pre> <p>Neste exemplo, o loop <code>for...in</code> iterar\u00e1 sobre as propriedades do objeto  \"pessoa\" (nome, idade e cidade) e imprimir\u00e1 seus nomes e valores. Certifique-se  de que as propriedades que voc\u00ea deseja iterar sejam enumer\u00e1veis, uma vez que  nem todas as propriedades de um objeto s\u00e3o enumer\u00e1veis por padr\u00e3o.</p>"},{"location":"basico/Loops/for-of/","title":"For...of","text":"<p>Em JavaScript, os la\u00e7os <code>for...of</code> s\u00e3o usados para percorrer elementos de uma  cole\u00e7\u00e3o iter\u00e1vel, como arrays, strings, objetos semelhantes a arrays (por  exemplo, NodeList) e muito mais. A estrutura b\u00e1sica de um la\u00e7o <code>for...of</code> \u00e9 a  seguinte:</p> <pre><code>for (let elemento of colecao) {\n    // Fa\u00e7a alguma coisa com o \"elemento\"\n}\n</code></pre> <p>Funciona assim:</p> <ol> <li> <p><code>for...of</code> \u00e9 uma estrutura de controle de loop que come\u00e7a com a  palavra-chave <code>for</code>.</p> </li> <li> <p><code>elemento</code> \u00e9 uma vari\u00e1vel que voc\u00ea escolhe para representar cada elemento da  cole\u00e7\u00e3o durante cada itera\u00e7\u00e3o do loop. Ela pode ser qualquer nome de vari\u00e1vel  v\u00e1lido em JavaScript.</p> </li> <li> <p><code>of</code> \u00e9 a palavra-chave que separa a vari\u00e1vel <code>elemento</code> da cole\u00e7\u00e3o  <code>colecao</code>.</p> </li> <li> <p><code>colecao</code> \u00e9 a cole\u00e7\u00e3o iter\u00e1vel que voc\u00ea deseja percorrer, como um array, uma  string, um objeto semelhante a um array (como NodeList) ou qualquer outro  objeto iter\u00e1vel.</p> </li> </ol> <p>Durante cada itera\u00e7\u00e3o do loop, o valor atual da cole\u00e7\u00e3o \u00e9 atribu\u00eddo \u00e0 vari\u00e1vel  <code>elemento</code>, permitindo que voc\u00ea execute a\u00e7\u00f5es com base nesse valor. Aqui est\u00e1  um exemplo de uso:</p> <pre><code>const frutas = ['ma\u00e7\u00e3', 'banana', 'laranja', 'morango'];\n\nfor (let fruta of frutas) {\n    console.log(fruta);\n}\n\n// ma\u00e7\u00e3\n// banana\n// laranja\n// morango\n</code></pre> <p>Neste exemplo, o loop <code>for...of</code> percorre o array <code>frutas</code> e a cada itera\u00e7\u00e3o, a  vari\u00e1vel <code>fruta</code> cont\u00e9m o valor atual do elemento do array. </p> <p>Os la\u00e7os <code>for...of</code> s\u00e3o uma maneira conveniente de percorrer cole\u00e7\u00f5es iter\u00e1veis  em JavaScript, evitando a necessidade de controlar manualmente os \u00edndices e  tornando o c\u00f3digo mais leg\u00edvel. Eles s\u00e3o especialmente \u00fateis quando voc\u00ea  precisa trabalhar com valores individuais de uma cole\u00e7\u00e3o sem se preocupar com a  complexidade de acessar cada elemento.</p>"},{"location":"basico/Loops/for/","title":"For (cl\u00e1ssico)","text":"<p>Os la\u00e7os <code>for</code> em JavaScript s\u00e3o usados para repetir um bloco de c\u00f3digo v\u00e1rias  vezes. Eles s\u00e3o frequentemente usados para percorrer arrays, executar uma s\u00e9rie  de instru\u00e7\u00f5es com uma contagem espec\u00edfica ou para realizar tarefas repetitivas.  </p> <p>Esta estrutura de <code>for</code> cl\u00e1ssico podemos iterar <code>arrays</code> e <code>strings</code>.</p> <p>Existem diferentes formas de usar a estrutura de controle <code>for</code> em JavaScript,  mas a forma mais comum \u00e9 a seguinte:</p> <pre><code>for (inicializa\u00e7\u00e3o; condi\u00e7\u00e3o; incremento) {\n  // C\u00f3digo a ser executado repetidamente\n}\n</code></pre> <p>Funciona assim:</p> <ol> <li> <p>Inicializa\u00e7\u00e3o: Nesta parte, voc\u00ea normalmente declara uma vari\u00e1vel e  atribui um valor inicial a ela. Essa parte \u00e9 executada uma vez no in\u00edcio do  la\u00e7o.</p> </li> <li> <p>Condi\u00e7\u00e3o: A condi\u00e7\u00e3o \u00e9 uma express\u00e3o que \u00e9 avaliada antes de cada  itera\u00e7\u00e3o do la\u00e7o. Se a condi\u00e7\u00e3o for avaliada como verdadeira (ou seja, retornar  <code>true</code>), o c\u00f3digo dentro do la\u00e7o \u00e9 executado. Se a condi\u00e7\u00e3o for avaliada como  falsa (ou seja, retornar <code>false</code>), o la\u00e7o \u00e9 encerrado.</p> </li> <li> <p>Incremento: Ap\u00f3s a execu\u00e7\u00e3o do c\u00f3digo no corpo do la\u00e7o, a parte de  incremento \u00e9 executada. Geralmente, isso envolve aumentar ou diminuir o valor  da vari\u00e1vel de controle, de modo que a condi\u00e7\u00e3o eventualmente se torne falsa e  o la\u00e7o seja encerrado.</p> </li> </ol> <p>Aqui est\u00e1 um exemplo simples que percorre os n\u00fameros de 1 a 5 e imprime cada  n\u00famero:</p> <pre><code>for (let i = 1; i &lt;= 5; i++) {\n  console.log(`-&gt; ${i}`);\n}\n\n// -&gt; 1\n// -&gt; 2\n// -&gt; 3\n// -&gt; 4\n// -&gt; 5\n</code></pre> <p>Este la\u00e7o come\u00e7a com <code>i</code> igual a 1. A cada itera\u00e7\u00e3o, ele verifica se <code>i</code> \u00e9  menor ou igual a 5. Se a condi\u00e7\u00e3o for verdadeira, ele executa o bloco de c\u00f3digo  (no caso, <code>console.log(i)</code>) e, em seguida, incrementa <code>i</code> em 1. O la\u00e7o continua  at\u00e9 que a condi\u00e7\u00e3o seja falsa.</p> <p>\u00c9 importante observar que a parte de inicializa\u00e7\u00e3o, condi\u00e7\u00e3o e  incremento s\u00e3o opcionais, embora voc\u00ea normalmente use todas elas para  controlar o comportamento do la\u00e7o. Al\u00e9m disso, voc\u00ea pode usar o <code>for</code> para  percorrer arrays, strings ou qualquer sequ\u00eancia de elementos, ajustando a  condi\u00e7\u00e3o e a vari\u00e1vel de controle conforme necess\u00e1rio.</p>"},{"location":"basico/Loops/while/","title":"While","text":"<p>O la\u00e7o <code>while</code> \u00e9 uma estrutura de controle em JavaScript que permite que voc\u00ea  execute um bloco de c\u00f3digo repetidamente enquanto uma determinada condi\u00e7\u00e3o for  verdadeira. Sua sintaxe \u00e9 a seguinte:</p> <pre><code>while (condi\u00e7\u00e3o) {\n  // C\u00f3digo a ser executado enquanto a condi\u00e7\u00e3o for verdadeira\n}\n</code></pre> <p>Funciona assim:</p> <ol> <li> <p>A condi\u00e7\u00e3o \u00e9 avaliada inicialmente. Se a condi\u00e7\u00e3o for avaliada como <code>true</code>,  o c\u00f3digo dentro do bloco do <code>while</code> \u00e9 executado.</p> </li> <li> <p>Ap\u00f3s a execu\u00e7\u00e3o do c\u00f3digo no bloco, a condi\u00e7\u00e3o \u00e9 avaliada novamente. Se a  condi\u00e7\u00e3o ainda for verdadeira, o c\u00f3digo no bloco \u00e9 executado novamente. Esse  processo se repete at\u00e9 que a condi\u00e7\u00e3o seja avaliada como <code>false</code>.</p> </li> <li> <p>Uma vez que a condi\u00e7\u00e3o se torne <code>false</code>, a execu\u00e7\u00e3o do la\u00e7o <code>while</code> \u00e9  interrompida e o controle do programa passa para a pr\u00f3xima instru\u00e7\u00e3o ap\u00f3s o  bloco <code>while</code>.</p> </li> </ol> <p>Aqui est\u00e1 um exemplo simples de como usar o la\u00e7o <code>while</code> para contar de 1 a 5:</p> <pre><code>let contador = 1;\n\nwhile (contador &lt;= 5) {\n  console.log(contador);\n  contador++;\n}\n\n// 1\n// 2\n// 3\n// 4\n// 5\n</code></pre> <p>Neste exemplo, o c\u00f3digo no bloco do <code>while</code> \u00e9 executado repetidamente enquanto  o valor da vari\u00e1vel <code>contador</code> for menor ou igual a 5. O <code>contador</code> \u00e9  incrementado a cada itera\u00e7\u00e3o, garantindo que eventualmente a condi\u00e7\u00e3o se torne  <code>false</code> e o la\u00e7o seja encerrado.</p> <p>Tenha cuidado ao usar o <code>while</code>, pois se a condi\u00e7\u00e3o nunca se tornar <code>false</code>,  seu programa entrar\u00e1 em um loop infinito, o que pode trav\u00e1-lo. Certifique-se de  que a condi\u00e7\u00e3o ser\u00e1 eventualmente falsa, a menos que voc\u00ea queira criar um loop  infinito intencionalmente.</p>"},{"location":"basico/arrays/arrays/","title":"Arrays","text":"<p>Um <code>array</code> em JavaScript \u00e9 uma estrutura de dados que permite armazenar uma  cole\u00e7\u00e3o de elementos em uma \u00fanica vari\u00e1vel. Os elementos em um <code>array</code> podem  ser de qualquer tipo de dados, como <code>n\u00fameros</code>, <code>strings</code>, <code>objetos</code>, <code>fun\u00e7\u00f5es</code>  e at\u00e9 outros <code>arrays</code>.  Cada elemento em um <code>array</code> \u00e9 acessado por um <code>\u00edndice</code>, que \u00e9 um n\u00famero  inteiro que representa a posi\u00e7\u00e3o do elemento no <code>array</code>.</p> <p>Vamos considerar o seguinte <code>array</code> abaixo:  </p> <pre><code>const alunos = ['Cesar', 'Ot\u00e1vio', 'Jady'];\nconsole.log(alunos);                   // ['Cesar', 'Ot\u00e1vio', 'Jady']\nconsole.log(typeof alunos);            // object\nconsole.log(alunos instanceof Array);  // true\n</code></pre> <p>Podemos acessar os elementos do <code>array</code> \u00e0 partir dos seus <code>\u00edndices</code>: <pre><code>console.log(alunos[0]);   // Cesar\nconsole.log(alunos[10]);  // undefined\n</code></pre></p> <p>Tamb\u00e9m \u00e9 possivel atualizar um elemento do <code>array</code> usando o seu <code>\u00edndice</code>: <pre><code>alunos[1] = 'Floriano';\nconsole.log(alunos);  // ['Cesar', 'Floriano', 'Jady']\n</code></pre></p> <p>Podemos inserir um novo elemento a um <code>array</code> apontando esse elemento para um  <code>\u00edndice</code> maior do que o \u00faltimo <code>\u00edndice</code> do <code>array</code>. <pre><code>alunos[3] = 'Ot\u00e1vio';\nconsole.log(alunos);  // ['Cesar', 'Floriano', 'Jady', 'Ot\u00e1vio']\n</code></pre></p>"},{"location":"basico/arrays/arrays/#metodos","title":"M\u00e9todos","text":""},{"location":"basico/arrays/arrays/#push","title":"push","text":"<p>Adiciona um elemento ao final da lista <pre><code>alunos.push('Fon');\nconsole.log(alunos);  // ['Cesar', 'Floriano', 'Jady', 'Ot\u00e1vio', 'Fon']\n</code></pre></p>"},{"location":"basico/arrays/arrays/#unshift","title":"unshift","text":"<p>adiciona um elemento ao in\u00edcio da lista <pre><code>alunos.unshift('Edu');\nconsole.log(alunos);  // ['Edu', 'Cesar', 'Floriano', 'Jady', 'Ot\u00e1vio', 'Fon']\n</code></pre></p>"},{"location":"basico/arrays/arrays/#pop","title":"pop","text":"<p>remove o \u00faltimo elemento <pre><code>alunos.pop();\nconsole.log(alunos);                    // ['Edu', 'Cesar', 'Floriano', 'Jady', 'Ot\u00e1vio']\nlet removido = alunos.pop();            // remove o \u00faltimo elemento e o atribui \u00e0 vari\u00e1vel removido\nconsole.log(`removido = ${removido}`);  // removido = Ot\u00e1vio\nconsole.log(alunos);                    // ['Edu', 'Cesar', 'Floriano', 'Jady']\n</code></pre></p>"},{"location":"basico/arrays/arrays/#shift","title":"shift","text":"<p>remove o primeiro elemento  <pre><code>alunos.shift();\nconsole.log(alunos);                    // ['Cesar', 'Floriano', 'Jady']\nremovido = alunos.shift();              // remove o primeiro elemento e o atribui \u00e0 vari\u00e1vel removido\nconsole.log(`removido = ${removido}`);  // removido = Cesar\nconsole.log(alunos);                    // ['Floriano', 'Jady']\n</code></pre></p>"},{"location":"basico/arrays/arrays/#delete","title":"delete","text":"<p>apaga o conte\u00fado de um \u00edndice <pre><code>delete alunos[0];\nconsole.log(alunos);  // [&lt;1 empty item&gt;, 'Jady']\n\n// ajustar a lista para os proximos exemplos\nalunos[0] = 'Cesar';\nalunos.push('Edu');\nalunos.push('Ot\u00e1vio');\nconsole.log(alunos);\n</code></pre></p>"},{"location":"basico/arrays/arrays/#slice","title":"slice","text":"<p>seleciona elementos sequenciais <pre><code>console.log(alunos.slice(0, 2));  // ['Cesar', 'Jady']\nconsole.log(alunos.slice(-2));    // ['Edu', 'Ot\u00e1vio']\n</code></pre></p>"},{"location":"basico/arrays/arrays/#join","title":"join","text":"<p>transforma um array em uma string <pre><code>const nomesAlunos = alunos.join(' ');\nconsole.log(nomesAlunos);  // Cesar Jady Edu Ot\u00e1vio \n</code></pre></p>"},{"location":"basico/arrays/arrays/#concat","title":"concat","text":"<p>concatena arrays <pre><code>const arr1 = [1, 2, 3];\nconst arr2 = [4, 5, 6];\nconst arr3 = arr1.concat(arr2, [7, 8, 9], 'Cesar');\nconsole.log(arr3);  // [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 'Cesar' ]\n</code></pre></p>"},{"location":"basico/arrays/arrays/#spread-operator","title":"spread operator <code>...</code>","text":"<p>usando o spread operator para concatenar <code>strings</code> <pre><code>const arr4 = [...arr1, 'Cesar', ...arr2, ...[7, 8, 9]];\nconsole.log(arr4);  // [ 1, 2, 3, 'Cesar', 4, 5, 6, 7, 8, 9 ]\n</code></pre></p>"},{"location":"basico/arrays/arrays/#splice","title":"splice","text":"<p>O m\u00e9todo <code>splice()</code> \u00e9 usado para alterar o conte\u00fado de um array, adicionando,  removendo ou substituindo elementos. Ele pode ser usado de v\u00e1rias maneiras e  possui os seguintes par\u00e2metros:</p> <pre><code>array.splice(start, deleteCount, item1, item2, ...)\n</code></pre> <ul> <li><code>start</code>: O \u00edndice no array a partir do qual as altera\u00e7\u00f5es devem come\u00e7ar.</li> <li><code>deleteCount</code>: O n\u00famero de elementos a serem removidos a partir do <code>start</code>.  Se for zero, nenhum elemento ser\u00e1 removido.</li> <li><code>item1, item2, ...</code>: Elementos a serem inseridos no array no lugar dos  elementos removidos.</li> </ul> <p>O m\u00e9todo <code>splice()</code> retorna um novo array contendo os elementos removidos.</p> <p>Aqui est\u00e3o alguns exemplos de como o m\u00e9todo <code>splice()</code> pode ser usado:</p>"},{"location":"basico/arrays/arrays/#remover-elementos","title":"Remover elementos","text":"<pre><code>const arr = [1, 2, 3, 4, 5];\nconst removed = arr.splice(1, 2);  // Remove 2 elementos a partir do \u00edndice 1\nconsole.log(arr);                  // [1, 4, 5]\nconsole.log(removed);              // [2, 3]\n</code></pre> <p>Simulando <code>pop</code> e <code>shift</code>: <pre><code>const arr = ['a', 'b', 'c', 'd', 'e'];\nconst removed = arr.splice(-1, 1);   // Remove 'e'  =  arr.pop()\nconsole.log(arr);                    // ['a', 'b', 'c', 'd']\nconsole.log(removed);                // ['e']\nconst removed2 = arr.splice(0, 1);   // Remove 'a'  =  arr.shift()\nconsole.log(arr);                    // ['b', 'c', 'd']\nconsole.log(removed2);               // ['a']\n</code></pre></p>"},{"location":"basico/arrays/arrays/#inserir-elementos","title":"Inserir elementos","text":"<pre><code>const arr = [1, 2, 3, 4, 5];\narr.splice(2, 0, 6, 7);   // Insere os elementos 6 e 7 a partir do \u00edndice 2\nconsole.log(arr);         // [1, 2, 6, 7, 3, 4, 5]\n</code></pre> <p>Simulando <code>push</code> e <code>unshift</code>: <pre><code>const arr = ['b', 'c', 'd'];\narr.splice(arr.length, 0, 'e');      // Adiciona 'e'  =  arr.push('e')\nconsole.log(arr);                    // ['b', 'c', 'd', 'e']\narr.splice(0, 0, 'a');               // Adiciona 'a'  =  arr.unshift('a')\nconsole.log(arr);                    // ['a', 'b', 'c', 'd', 'e']\n</code></pre></p>"},{"location":"basico/arrays/arrays/#substituir-elementos","title":"Substituir elementos","text":"<pre><code>const arr = [1, 2, 3, 4, 5];\narr.splice(2, 2, 6, 7);   // Substitui os elementos 3 e 4 pelos elementos \n                          // 6 e 7 a partir do \u00edndice 2\nconsole.log(arr);         // [1, 2, 6, 7, 5]\n</code></pre> <p>Tenha em mente que o m\u00e9todo <code>splice()</code> modifica o array original, e os  elementos removidos s\u00e3o retornados em um novo array. Portanto, \u00e9 uma opera\u00e7\u00e3o  destrutiva. Certifique-se de entender como o m\u00e9todo funciona e de que forma  ele afetar\u00e1 o seu array antes de utiliz\u00e1-lo.</p>"},{"location":"basico/arrays/filter/","title":"Filter","text":"<p>O m\u00e9todo <code>filter()</code> \u00e9 uma fun\u00e7\u00e3o de array que permite criar um novo array a  partir de um array existente, contendo apenas os elementos que atendem a uma  determinada condi\u00e7\u00e3o. Ele n\u00e3o modifica o array original, mas retorna um novo  array com os elementos filtrados. A sintaxe b\u00e1sica do m\u00e9todo <code>filter()</code> \u00e9 a  seguinte:</p> <pre><code>const novoArray = arrayOriginal.filter(function(elemento) {\n    // Condi\u00e7\u00e3o de filtragem\n    return condi\u00e7\u00e3o;\n});\n</code></pre> <p>O <code>filter()</code> funciona assim:</p> <ol> <li> <p><code>arrayOriginal</code>: Este \u00e9 o array que voc\u00ea deseja filtrar.</p> </li> <li> <p><code>function(elemento)</code>: Esta \u00e9 a fun\u00e7\u00e3o de callback que \u00e9 chamada para cada  elemento do <code>arrayOriginal</code>. Ela recebe como primeiro argumento, o elemento  atual sendo processado.  Mas pode receber tamb\u00e9m mas dois argumentos: o  <code>\u00edndice</code> e o pr\u00f3prio <code>array</code>.</p> </li> <li> <p><code>condi\u00e7\u00e3o</code>: \u00c9 a condi\u00e7\u00e3o que voc\u00ea especifica dentro da fun\u00e7\u00e3o de callback.  Se a condi\u00e7\u00e3o for avaliada como <code>true</code> para um elemento espec\u00edfico, esse  elemento ser\u00e1 inclu\u00eddo no novo array. Se a condi\u00e7\u00e3o for avaliada como <code>false</code>,  o elemento ser\u00e1 exclu\u00eddo do novo array.</p> </li> </ol> <p>O resultado \u00e9 um novo array contendo apenas os elementos que atendem \u00e0 condi\u00e7\u00e3o  especificada na fun\u00e7\u00e3o de callback.</p> <p>Aqui est\u00e1 um exemplo simples de uso do m\u00e9todo <code>filter()</code> para criar um novo  array contendo apenas n\u00fameros pares de um array original:</p> <pre><code>const numeros = [1, 2, 3, 4, 5, 6, 7, 8];\nconst numerosPares = numeros.filter(function(numero) {\n    return numero % 2 === 0;\n});\n\nconsole.log(numerosPares);  // [2, 4, 6, 8]\n</code></pre> <p>Neste exemplo, a fun\u00e7\u00e3o de callback verifica se cada n\u00famero no array \u00e9 par  (ou seja, se o resto da divis\u00e3o por 2 \u00e9 igual a 0), e os n\u00fameros pares s\u00e3o  inclu\u00eddos no novo array <code>numerosPares</code>.</p>"},{"location":"basico/arrays/filter/#exemplos","title":"Exemplos","text":""},{"location":"basico/arrays/filter/#usando-arrow-function","title":"Usando arrow function","text":"<pre><code>const numeros = [5, 50, 80, 1, 2, 3, 5, 8, 7, 11, 15, 22, 27];\n\n// retorne os n\u00fameros maiores que 10\nconst filtered = numeros.filter(num =&gt; num &gt; 10);\nconsole.log(filtered);   // [ 50, 80, 11, 15, 22, 27 ]\n</code></pre>"},{"location":"basico/arrays/filter/#array-de-objects","title":"Array de Objects","text":"<pre><code>const pessoas = [\n    { nome: 'Jady', idade: 38 },\n    { nome: 'Cesar', idade: 53 },\n    { nome: 'Maria', idade: 65 },\n    { nome: 'Jo\u00e3o', idade: 23 },\n    { nome: 'Floriano', idade: 63 },\n    { nome: 'Nanci', idade: 13 },\n]\n\n\n// retorne as pessoas que tem o nome com 5 letras ou mais\nconst nameL5 = pessoas.filter(pessoa =&gt; pessoa.nome.length &gt;= 5);\nconsole.log(nameL5);\n// [\n//     { nome: 'Cesar', idade: 53 },\n//     { nome: 'Maria', idade: 65 },\n//     { nome: 'Floriano', idade: 63 },\n//     { nome: 'Nanci', idade: 13 }\n// ]\n\n\n// retorne as pessoas com mais de 50 anos\nconst idade50 = pessoas.filter(pessoa =&gt; pessoa.idade &gt; 50);\nconsole.log(idade50);\n// [\n//     { nome: 'Cesar', idade: 53 },\n//     { nome: 'Maria', idade: 65 },\n//     { nome: 'Floriano', idade: 63 }\n// ]\n\n\n// retorne as pessoas cujo nome termina com 'a'\nconst nomeTerminaA = pessoas.filter(p =&gt; p.nome.toLowerCase().endsWith('a'));\nconsole.log(nomeTerminaA);  // [ { nome: 'Maria', idade: 65 } ]\n</code></pre>"},{"location":"basico/arrays/map/","title":"Map","text":"<p>O m\u00e9todo <code>map()</code> \u00e9 usado para criar um novo array a partir de um array  existente, aplicando uma fun\u00e7\u00e3o a cada elemento do array original e coletando  os resultados em um novo array. O novo array ter\u00e1 o mesmo comprimento do array  original, mas os valores em cada posi\u00e7\u00e3o ser\u00e3o determinados pela fun\u00e7\u00e3o de  mapeamento.</p> <p>A sintaxe b\u00e1sica do m\u00e9todo <code>map()</code> \u00e9 a seguinte:</p> <pre><code>const novoArray = arrayOriginal.map(function(elemento, \u00edndice, array) {\n  // C\u00f3digo que transforma o elemento\n  // Retorna o novo valor para o novo array\n});\n</code></pre> <p>Aqui est\u00e3o os par\u00e2metros e seus significados:</p> <ul> <li><code>elemento</code>: O valor do elemento atual do array original.</li> <li><code>\u00edndice</code> (opcional): A posi\u00e7\u00e3o do elemento no array original.</li> <li><code>array</code> (opcional): O array original sendo percorrido.</li> </ul> <p>O m\u00e9todo <code>map()</code> itera sobre cada elemento do array original, chama a fun\u00e7\u00e3o  de mapeamento fornecida para cada elemento e armazena o valor retornado no novo  array. O novo array \u00e9 ent\u00e3o retornado como resultado.</p> <p>Aqui est\u00e1 um exemplo simples que usa o m\u00e9todo <code>map()</code> para duplicar cada  elemento de um array:</p> <pre><code>const n\u00fameros = [1, 2, 3, 4, 5];\nconst duplicados = n\u00fameros.map(function(numero) {\n  return numero * 2;\n});\n\nconsole.log(duplicados);  // [2, 4, 6, 8, 10]\n</code></pre> <p>Podemos tamb\u00e9m usar <code>arrow functions</code> para tornar o c\u00f3digo mais conciso:</p> <pre><code>const n\u00fameros = [1, 2, 3, 4, 5];\nconst duplicados = n\u00fameros.map(numero =&gt; numero * 2);\n\nconsole.log(duplicados);  // [2, 4, 6, 8, 10]\n</code></pre> <p>O m\u00e9todo <code>map()</code> \u00e9 muito \u00fatil para transformar dados em arrays e \u00e9 uma das  ferramentas fundamentais para trabalhar com arrays em JavaScript.</p>"},{"location":"basico/arrays/map/#exemplos","title":"Exemplos","text":""},{"location":"basico/arrays/map/#usando-arrow-function","title":"Usando arrow function","text":"<pre><code>const numeros = [5, 50, 80, 1, 2, 3, 5, 8, 7];\n\n// dobre o valor de cada n\u00famero\nconst dobro = numeros.map(num =&gt; num * 2);\nconsole.log(dobro);  // [ 10, 100, 160,  2,  4,  6, 10,  16,  14 ]\n</code></pre>"},{"location":"basico/arrays/map/#array-de-objects","title":"Array de Objects","text":"<pre><code>const pessoas = [\n    { nome: 'Jady', idade: 38 },\n    { nome: 'Cesar', idade: 53 },\n    { nome: 'Maria', idade: 65 },\n    { nome: 'Jo\u00e3o', idade: 23 },\n    { nome: 'Floriano', idade: 63 },\n]\n\n\n// retorne uma string com o nome da pessoa\nconst nomes = pessoas.map(obj =&gt; obj.nome);\nconsole.log(nomes);  // [ 'Jady', 'Cesar', 'Maria', 'Jo\u00e3o', 'Floriano' ]\n\n\n// retorne a chave 'nome'do objeto (retorne apenas idade)\nconst idades = pessoas.map(obj =&gt; ({ idade: obj.idade }));\nconsole.log(idades);\n// [\n//   { idade: 38 },\n//   { idade: 53 },\n//   { idade: 65 },\n//   { idade: 23 },\n//   { idade: 63 }\n// ]\n\n\n// adicione uma chave de id em cada objeto\nconst ids = pessoas.map((obj, i) =&gt; {\n    const newObj = { ...obj };\n    newObj.id = i;\n    return newObj;\n});\nconsole.log(ids);\n// [\n//     { nome: 'Jady', idade: 38, id: 0 },\n//     { nome: 'Cesar', idade: 53, id: 1 },\n//     { nome: 'Maria', idade: 65, id: 2 },\n//     { nome: 'Jo\u00e3o', idade: 23, id: 3 },\n//     { nome: 'Floriano', idade: 63, id: 4 }\n// ]\n</code></pre>"},{"location":"basico/arrays/reduce/","title":"Reduce","text":"<p>A fun\u00e7\u00e3o <code>reduce</code> \u00e9 um m\u00e9todo de array que permite reduzir (ou \"acumular\") os  elementos de um array a um \u00fanico valor. Ela \u00e9 muito \u00fatil quando voc\u00ea deseja  realizar alguma opera\u00e7\u00e3o em todos os elementos de um array e produzir um  resultado \u00fanico, como somar todos os elementos, calcular a m\u00e9dia, encontrar o  maior ou o menor valor, etc.</p> <p>A sintaxe b\u00e1sica da fun\u00e7\u00e3o <code>reduce</code> \u00e9 a seguinte:</p> <pre><code>array.reduce(callback[, initialValue]);\n</code></pre> <ul> <li><code>array</code>: O array no qual voc\u00ea deseja operar.</li> <li><code>callback</code>: Uma fun\u00e7\u00e3o que \u00e9 executada em cada elemento do array e recebe  quatro argumentos: <code>acumulador</code>, <code>valor atual</code>, <code>\u00edndice atual</code> e  <code>array original</code>. O acumulador \u00e9 o resultado parcial da opera\u00e7\u00e3o e o valor  atual \u00e9 o elemento atual do array.</li> <li><code>initialValue</code> (opcional): Um valor inicial para o acumulador. Se fornecido,  a fun\u00e7\u00e3o <code>reduce</code> come\u00e7ar\u00e1 a opera\u00e7\u00e3o com esse valor como acumulador. Se n\u00e3o  fornecido, o acumulador ser\u00e1 o primeiro elemento do array e a fun\u00e7\u00e3o <code>callback</code>  come\u00e7ar\u00e1 a opera\u00e7\u00e3o a partir do segundo elemento.</li> </ul> <p>Aqui est\u00e1 um exemplo simples de uso do <code>reduce</code> para somar todos os elementos  de um array:</p> <pre><code>const numbers = [1, 2, 3, 4, 5];\n\nconst sum = numbers.reduce((accumulator, currentValue) =&gt; {\n  return accumulator + currentValue;\n}, 0);\n\nconsole.log(sum);  // Output: 15\n</code></pre> <p>Neste exemplo, <code>0</code> \u00e9 fornecido como <code>initialValue</code>, e a fun\u00e7\u00e3o <code>callback</code> soma  o acumulador com o valor atual em cada itera\u00e7\u00e3o, resultando na soma total de  todos os elementos do array.</p> <p>A fun\u00e7\u00e3o <code>reduce</code> \u00e9 vers\u00e1til e pode ser usada para realizar v\u00e1rias opera\u00e7\u00f5es em  arrays, dependendo da l\u00f3gica definida na fun\u00e7\u00e3o <code>callback</code>. Voc\u00ea pode us\u00e1-la  para encontrar o maior valor, o menor valor, calcular a m\u00e9dia, concatenar  strings e muito mais. A chave para seu uso eficaz est\u00e1 na defini\u00e7\u00e3o da fun\u00e7\u00e3o  <code>callback</code> de acordo com a opera\u00e7\u00e3o desejada.</p>"},{"location":"basico/arrays/reduce/#exemplos","title":"Exemplos","text":"<p>Dado o array abaixo: <pre><code>const numeros = [5, 50, 80, 1, 2, 3, 5, 8, 7, 11, 15, 22, 27];\n</code></pre></p>"},{"location":"basico/arrays/reduce/#some-todos-os-valores","title":"some todos os valores","text":"<pre><code>const total = numeros.reduce((tot, num) =&gt; tot += num, 0);\nconsole.log(total);  // 236\n</code></pre>"},{"location":"basico/arrays/reduce/#retorne-um-array-com-os-pares-filter","title":"retorne um array com os pares (filter)","text":"<pre><code>const pares = numeros.reduce((pars, num) =&gt; {\n    if (num % 2 === 0) pars.push(num);\n    return pars;\n}, [])\nconsole.log(pares);  // [ 50, 80, 2, 8, 22 ]\n</code></pre>"},{"location":"basico/arrays/reduce/#retorne-um-array-com-o-dobro-dos-valores-map","title":"retorne um array com o dobro dos valores (map)","text":"<pre><code>const dobro = numeros.reduce((dobro, num) =&gt; {\n    dobro.push(num * 2);\n    return dobro;\n}, [])\nconsole.log(dobro);  // [ 10, 100, 160, 2, 4, 6, 10, 16, 14, 22, 30, 44, 54 ]\n</code></pre>"},{"location":"basico/arrays/reduce/#retorne-a-pessoa-mais-velha","title":"retorne a pessoa mais velha","text":"<pre><code>const pessoas = [\n    { nome: 'Jady', idade: 38 },\n    { nome: 'Cesar', idade: 53 },\n    { nome: 'Maria', idade: 65 },\n    { nome: 'Jo\u00e3o', idade: 23 },\n]\nconst maisVelha = pessoas.reduce((old, obj) =&gt; {\n    if (old.idade &gt; obj.idade) return old;\n    return obj\n})\nconsole.log(maisVelha);   // { nome: 'Maria', idade: 65 }\n</code></pre>"},{"location":"basico/arrays/reduce/#all-in-one","title":"all-in-one","text":"<p>Encadeando <code>filter</code> + <code>map</code> + <code>reduce</code> \ud83d\ude0a</p> <pre><code>const numeros = [5, 50, 80, 1, 2, 3, 5, 8, 7, 11, 15, 22, 27];\n\n// retorne a soma de todos os n\u00fameros pares\nconst somaDosPares = numeros\n    .filter(num =&gt; num % 2 === 0)\n    .map(num =&gt; num * 2)\n    .reduce((tot, num) =&gt; tot += num, 0);\nconsole.log(somaDosPares);  // 324\n</code></pre>"},{"location":"basico/errors/throw/","title":"Throw","text":"<p>A palavra-chave <code>throw</code> em JavaScript \u00e9 usada para lan\u00e7ar exce\u00e7\u00f5es (erros) em  seu c\u00f3digo. Quando uma exce\u00e7\u00e3o \u00e9 lan\u00e7ada com <code>throw</code>, a execu\u00e7\u00e3o normal do  programa \u00e9 interrompida e o controle \u00e9 transferido para o bloco <code>catch</code> mais  pr\u00f3ximo no contexto de tratamento de exce\u00e7\u00e3o (como em uma estrutura  <code>try...catch</code>) que pode manipular a exce\u00e7\u00e3o lan\u00e7ada.</p> <p>Aqui est\u00e1 a sintaxe b\u00e1sica do <code>throw</code> em JavaScript:</p> <pre><code>throw expression;\n</code></pre> <ul> <li><code>expression</code>: A express\u00e3o que representa o valor da exce\u00e7\u00e3o a ser lan\u00e7ada.  Pode ser uma string, um n\u00famero, um objeto ou qualquer outro tipo de valor.</li> </ul> <p>Aqui est\u00e1 um exemplo simples de como usar <code>throw</code>:</p> <pre><code>function divide(a, b) {\n  if (b === 0) {\n    throw \"Divis\u00e3o por zero n\u00e3o \u00e9 permitida.\";\n  }\n  return a / b;\n}\n\ntry {\n  var result = divide(10, 0);\n  console.log(\"Resultado: \" + result);\n} catch (error) {\n  console.error(\"Erro: \" + error);\n}\n\n// Divis\u00e3o por zero n\u00e3o \u00e9 permitida.\n</code></pre> <p>Neste exemplo, a fun\u00e7\u00e3o <code>divide</code> verifica se <code>b</code> \u00e9 igual a zero e, se for,  lan\u00e7a uma exce\u00e7\u00e3o com a mensagem \"Divis\u00e3o por zero n\u00e3o \u00e9 permitida.\" A exce\u00e7\u00e3o  \u00e9 ent\u00e3o capturada no bloco <code>catch</code>, e a mensagem de erro \u00e9 exibida no console.</p> <p>Voc\u00ea tamb\u00e9m pode lan\u00e7ar objetos de exce\u00e7\u00e3o personalizados em JavaScript, que  podem conter informa\u00e7\u00f5es adicionais sobre o erro, como tipo, mensagem e outras  propriedades personalizadas. Por exemplo:</p> <pre><code>function customError(message) {\n  this.name = \"CustomError\";\n  this.message = message || \"Erro personalizado ocorreu.\";\n}\n\ncustomError.prototype = Object.create(Error.prototype);\ncustomError.prototype.constructor = customError;\n\nfunction throwErrorExample() {\n  throw new customError(\"Isso \u00e9 um erro personalizado.\");\n}\n\ntry {\n  throwErrorExample();\n} catch (error) {\n  console.error(error.name + \": \" + error.message);\n}\n\n// CustomError: Isso \u00e9 um erro personalizado.\n</code></pre> <p>Neste exemplo, definimos um construtor de erro personalizado <code>customError</code> que  herda das propriedades padr\u00e3o do objeto <code>Error</code>. Em seguida, usamos  <code>throw new customError(...)</code> para lan\u00e7ar uma inst\u00e2ncia de erro personalizado e,  em seguida, capturamos e exibimos os detalhes do erro no bloco <code>catch</code>.</p>"},{"location":"basico/errors/try-catch-finally/","title":"Try - Catch - Finally","text":"<p>Em JavaScript, <code>try</code>, <code>catch</code>, e <code>finally</code> s\u00e3o constru\u00e7\u00f5es usadas para lidar  com exce\u00e7\u00f5es (erros) que podem ocorrer durante a execu\u00e7\u00e3o de um bloco de  c\u00f3digo. Aqui est\u00e1 uma explica\u00e7\u00e3o de como eles funcionam:</p>"},{"location":"basico/errors/try-catch-finally/#try","title":"<code>try</code>","text":"<p>O bloco <code>try</code> \u00e9 usado para envolver o c\u00f3digo que voc\u00ea acredita que  pode gerar uma exce\u00e7\u00e3o. Quando um erro ocorre dentro do bloco <code>try</code>, o fluxo  de controle \u00e9 transferido imediatamente para o bloco <code>catch</code>. <pre><code>try {\n  // C\u00f3digo que pode gerar uma exce\u00e7\u00e3o\n} catch (error) {\n  // C\u00f3digo para lidar com a exce\u00e7\u00e3o\n}\n</code></pre></p>"},{"location":"basico/errors/try-catch-finally/#catch","title":"<code>catch</code>","text":"<p>O bloco <code>catch</code> \u00e9 usado para capturar (ou \"pegar\") uma exce\u00e7\u00e3o  gerada no bloco <code>try</code>. O par\u00e2metro <code>error</code> (ou qualquer nome que voc\u00ea escolher)  \u00e9 uma refer\u00eancia \u00e0 exce\u00e7\u00e3o que foi lan\u00e7ada. Voc\u00ea pode usar essa refer\u00eancia  para examinar detalhes sobre o erro, como a mensagem de erro, o tipo de erro  etc., e tomar medidas apropriadas para lidar com a exce\u00e7\u00e3o. <pre><code>try {\n  // C\u00f3digo que pode gerar uma exce\u00e7\u00e3o\n} catch (error) {\n  // C\u00f3digo para lidar com a exce\u00e7\u00e3o\n  console.error(error.message);\n}\n</code></pre></p>"},{"location":"basico/errors/try-catch-finally/#finally","title":"<code>finally</code>","text":"<p>O bloco <code>finally</code> \u00e9 opcional e \u00e9 usado para definir c\u00f3digo que  ser\u00e1 executado, independentemente de ocorrer ou n\u00e3o uma exce\u00e7\u00e3o dentro do bloco  <code>try</code>. Isso \u00e9 \u00fatil para a\u00e7\u00f5es que devem ser executadas sempre, como a limpeza  de recursos, independentemente de um erro ter ocorrido ou n\u00e3o. <pre><code>try {\n  // C\u00f3digo que pode gerar uma exce\u00e7\u00e3o\n} catch (error) {\n  // C\u00f3digo para lidar com a exce\u00e7\u00e3o\n} finally {\n  // C\u00f3digo que sempre ser\u00e1 executado\n}\n</code></pre></p> <p>A ordem de execu\u00e7\u00e3o \u00e9 a seguinte:</p> <ol> <li>O c\u00f3digo no bloco <code>try</code> \u00e9 executado.</li> <li>Se uma exce\u00e7\u00e3o ocorrer no bloco <code>try</code>, o controle \u00e9 transferido para o bloco  <code>catch</code>, onde o erro \u00e9 tratado.</li> <li>Ap\u00f3s a execu\u00e7\u00e3o do bloco <code>try</code> ou do bloco <code>catch</code>, o bloco <code>finally</code> \u00e9  executado, se presente.</li> </ol> <p>A estrutura <code>try-catch-finally</code> permite que voc\u00ea lide com exce\u00e7\u00f5es de maneira  controlada, evitando que erros interrompam a execu\u00e7\u00e3o do seu programa e  fornecendo a oportunidade de realizar a\u00e7\u00f5es de limpeza, se necess\u00e1rio.</p>"},{"location":"fun%C3%A7%C3%B5es/closures/","title":"Closures","text":"<p>Uma \"closure\" \u00e9 uma fun\u00e7\u00e3o que \"lembra\" o ambiente em que foi criada, incluindo  todas as vari\u00e1veis locais e par\u00e2metros da fun\u00e7\u00e3o exterior a ela. Isso permite  que a fun\u00e7\u00e3o tenha acesso a essas vari\u00e1veis mesmo ap\u00f3s a fun\u00e7\u00e3o externa ter  sido conclu\u00edda e retornada. As closures s\u00e3o uma caracter\u00edstica poderosa da  linguagem e t\u00eam v\u00e1rias aplica\u00e7\u00f5es.</p> <p>Para entender melhor as closures, \u00e9 importante ter em mente os seguintes  conceitos:</p> <ol> <li> <p>Fun\u00e7\u00f5es aninhadas: Em JavaScript, voc\u00ea pode definir fun\u00e7\u00f5es dentro de outras  fun\u00e7\u00f5es. A fun\u00e7\u00e3o interna \u00e9 chamada de fun\u00e7\u00e3o aninhada.</p> </li> <li> <p>Escopo l\u00e9xico: Em JavaScript, as fun\u00e7\u00f5es s\u00e3o definidas com base em um escopo  l\u00e9xico, o que significa que elas t\u00eam acesso \u00e0s vari\u00e1veis de seu ambiente pai  (fun\u00e7\u00e3o que a envolve).</p> </li> </ol> <p>Uma closure ocorre quando uma fun\u00e7\u00e3o interna (fun\u00e7\u00e3o aninhada) \u00e9 retornada de  uma fun\u00e7\u00e3o externa e, em seguida, \u00e9 chamada fora do escopo da fun\u00e7\u00e3o externa. </p> <p>Aqui est\u00e1 um exemplo simples de uma closure:</p> <pre><code>function outerFunction(inicio) {\n    let [var1, var2, var3] = \"&lt;| || |&gt;\".split(' ');\n\n    function innerFunction(fim) {\n        return `${var1} ${inicio} ${var2} ${fim} ${var3}`;\n    }\n\n    return innerFunction; // Retorna a fun\u00e7\u00e3o interna\n}\n\nconst teste = outerFunction('Aqui \u00e9 o in\u00edcio');\nconsole.log(teste('aqui o fim'));  // &lt;| Aqui \u00e9 o in\u00edcio || aqui o fim |&gt;\n</code></pre> <p>Neste exemplo, <code>innerFunction</code> \u00e9 uma closure porque ela \"lembra\" o escopo de  <code>outerFunction</code> mesmo ap\u00f3s a <code>outerFunction</code> ter retornado e foi atribu\u00edda a  <code>closure</code>.</p> <p>As closures s\u00e3o \u00fateis para criar fun\u00e7\u00f5es que encapsulam estados e  comportamentos espec\u00edficos, permitindo que voc\u00ea crie fun\u00e7\u00f5es que mantenham  informa\u00e7\u00f5es entre chamadas, como fun\u00e7\u00f5es de f\u00e1brica, geradores, manipuladores  de eventos e muito mais. Elas s\u00e3o uma parte fundamental do JavaScript e  desempenham um papel importante na cria\u00e7\u00e3o de c\u00f3digo flex\u00edvel e reutiliz\u00e1vel.</p> <p>Um exemplo mais pr\u00e1tico:</p> <pre><code>function multiplicador(multipl) {\n    return function (num) {\n        return num * multipl;\n    }\n}\n\nconst duplica = multiplicador(2);\nconst triplica = multiplicador(3);\n\nconsole.log(duplica(35));  // 70\nconsole.log(triplica(35));  // 105\n</code></pre>"},{"location":"fun%C3%A7%C3%B5es/constructor-function/","title":"Constructor function","text":"<p>Uma <code>constructor function</code> \u00e9 uma fun\u00e7\u00e3o que \u00e9 usada para criar objetos. Ela  atua como um \"modelo\" para criar m\u00faltiplos objetos com as mesmas propriedades  e m\u00e9todos.</p> <p>Aqui est\u00e1 um exemplo de constructor function:</p> <pre><code>function Pessoa(nome, sobrenome, alt, pes) {\n    const secret = '12bf4W';  // atributo privado\n\n    this.nome = nome;\n    this.sobrenome = sobrenome;\n    this.altura = alt;\n    this.peso = pes;\n\n    this.nomeCompleto = `${this.nome} ${this.sobrenome}`;\n    this.imc = (this.peso / (this.altura ** 2)).toFixed(2);\n\n    this.fala = (assunto) =&gt; {\n        return `${this.nome} disse ${assunto}`;\n    };\n\n}\n</code></pre> <p>Neste exemplo podemos instanciar novas pessoas, usando a palavra-chave <code>new</code>.</p> <pre><code>const pessoa1 = new Pessoa('Arnaldo', 'Fagundes', 1.87, 102);\nconsole.log(pessoa1.secret);          // atributo privado: acesso proibido\nconsole.log(pessoa1);                 // { nome: 'Arnaldo', ... }\nconsole.log(pessoa1.nomeCompleto);    // Arnaldo Fagundes\nconsole.log(pessoa1.fala('python'));  // Arnaldo dissee python\nconsole.log(pessoa1.imc);             // 29.17\n</code></pre> <p>A principal vantagem das constructor functions \u00e9 a capacidade de criar objetos  com a mesma estrutura e comportamento de uma maneira mais organizada e  reutiliz\u00e1vel. Elas s\u00e3o frequentemente usadas em conjunto com prot\u00f3tipos para  adicionar m\u00e9todos compartilhados entre as inst\u00e2ncias dos objetos criados a  partir da constructor function.</p>"},{"location":"fun%C3%A7%C3%B5es/factory-function/","title":"Factory function","text":"<p>Uma <code>factory function</code> \u00e9 uma fun\u00e7\u00e3o que cria e retorna objetos. Ela \u00e9 usada  para encapsular a cria\u00e7\u00e3o de objetos, o que pode ser \u00fatil para criar v\u00e1rias  inst\u00e2ncias de objetos sem a necessidade de escrever c\u00f3digo repetitivo.</p> <p>A principal caracter\u00edstica de uma <code>factory function</code> \u00e9 que ela encapsula a  l\u00f3gica de cria\u00e7\u00e3o de um objeto em uma fun\u00e7\u00e3o e retorna novas inst\u00e2ncias desse  objeto toda vez que \u00e9 invocada. Essa abordagem \u00e9 uma forma de implementar o  conceito de \"fabrica\u00e7\u00e3o\" de objetos, onde a fun\u00e7\u00e3o age como uma f\u00e1brica que  produz objetos com base em um modelo ou estrutura predefinida.</p> <p>Vejamos um exemplo simples de uma <code>factory function</code>:</p> <pre><code>function criarPessoa(name, idade) {\n  return {\n    name,  // quando o a chave do argumento vai ser a mesma do retorno n\u00e3o \n           // precisamos escrever -&gt; name: name\n    age: idade,\n    cumprimentar: function() {\n      console.log(`Ol\u00e1, meu nome \u00e9 ${this.name} e tenho ${this.age} anos.`);\n    },\n    ficarMaisVelho(anos = 1) {\n        return this.age += anos;\n    }\n  };\n}\n</code></pre> <p>Neste exemplo, a fun\u00e7\u00e3o <code>criarPessoa</code> \u00e9 uma <code>factory function</code> que cria  objetos pessoa com as propriedades <code>name</code>, <code>idade</code> e dois m\u00e9todos:   </p> <ul> <li><code>cumprimentar</code></li> <li><code>ficarMaisVelho</code></li> </ul> <pre><code>var pessoa1 = criarPessoa(\"Jo\u00e3o\", 30);\nvar pessoa2 = criarPessoa(\"Maria\", 25);\n\npessoa1.cumprimentar();     // Ol\u00e1, meu nome \u00e9 Jo\u00e3o e tenho 30 anos.\npessoa2.cumprimentar();     // Ol\u00e1, meu nome \u00e9 Maria e tenho 25 anos.\n\npessoa1.ficarMaisVelho();   // aumenta 1 ano para Jo\u00e3o\npessoa1.cumprimentar();     // Ol\u00e1, meu nome \u00e9 Jo\u00e3o e tenho 31 anos.\n\npessoa2.ficarMaisVelho(4);  // aumenta 4 anos para Maria\npessoa2.cumprimentar();     // Ol\u00e1, meu nome \u00e9 Maria e tenho 29 anos.\n</code></pre>"},{"location":"fun%C3%A7%C3%B5es/factory-function/#getters-e-setters","title":"getters e setters","text":"<p><code>Factory functions</code> podem ter getters e setters.  Isso permite controlar o  acesso e a modifica\u00e7\u00e3o das propriedades do objeto de forma mais precisa, se  necess\u00e1rio.</p> <pre><code>function pessoa(nome, sobrenome, alt, pes) {\n    return {\n        nome,\n        sobrenome,\n        // get -&gt; getter\n        get nomeCompleto() {\n            return `${this.nome} ${this.sobrenome}`;\n        },\n        // set -&gt; setter\n        set nomeCompleto(text) {\n            text = text.split(' ');\n            this.nome = text.shift();\n            this.sobrenome = text.join(' ');\n        },\n        altura: alt,\n        peso: pes,\n        fala(assunto) {\n            return `${this.nome} est\u00e1 falando sobre ${assunto}`;\n        },\n\n        get imc() {\n            return (this.peso / (this.altura ** 2)).toFixed(2);\n        }\n    }\n}\n\nconst p1 = pessoa('Jucelino', 'Guanabara', 1.87, 106);\nconsole.log(p1);  \n// { nome: 'Jucelino', sobrenome: 'Guanabara', nomeCompleto: [Getter/Setter], \n//   altura: 1.87, peso: 106, fala: [Function: fala], imc: [Getter] }\nconsole.log(p1.nomeCompleto);  // Jucelino Guanabara \nconsole.log(p1.fala('JavaScript'));  // Jucelino est\u00e1 falando sobre JavaScript\nconsole.log(p1.imc);  // 30.31\np1.nomeCompleto = 'Tiburcio Caetano';\nconsole.log(p1.nomeCompleto);  // Tiburcio Caetano\n</code></pre>"},{"location":"fun%C3%A7%C3%B5es/function-declaration/","title":"Declara\u00e7\u00e3o de fun\u00e7\u00f5es","text":"<p>Em JavaScript, voc\u00ea pode declarar fun\u00e7\u00f5es de v\u00e1rias maneiras. As formas mais  comuns de declarar fun\u00e7\u00f5es s\u00e3o a <code>function declaration</code> (forma tradicional),  a <code>function expression</code> e temos tamb\u00e9m as <code>arrow functions</code>.</p>"},{"location":"fun%C3%A7%C3%B5es/function-declaration/#function-declaration","title":"function declaration","text":"<pre><code>function nomeDaFuncao(parametros) {\n    // corpo da fun\u00e7\u00e3o\n    return resultado  // pode ou n\u00e3o retornar um resultado\n}\n</code></pre> <p>Para fun\u00e7\u00f5es tradicionais, ocorre o <code>hoisting</code>, que \u00e9 a eleva\u00e7\u00e3o dessas fun\u00e7\u00f5es  para o in\u00edcio do script em tempo de execu\u00e7\u00e3o, o que permite invocar (em tempo  de desenvolvimento) a fun\u00e7\u00e3o, mesmo antes dela ser declarada.</p> <pre><code>falaOie();     // fun\u00e7\u00e3o invocada antes da sua declara\u00e7\u00e3o  -&gt;  oie\n\nfunction falaOie() {\n    console.log('oie');\n}\n</code></pre>"},{"location":"fun%C3%A7%C3%B5es/function-declaration/#function-expression","title":"Function expression","text":"<p>O fato de as fun\u00e7\u00f5es serem objetos de primeira classe (first-class objects),  nos permite atribu\u00ed-las \u00e0 vari\u00e1veis.  Isso justifica esta segunda forma de  declarar nossas fun\u00e7\u00f5es.</p> <pre><code>const dobra = function (num) {\n    return num * 2;\n}\n\nconsole.log(dobra(2));   // 4\n</code></pre> <p>Podemos inclusive receber uma fun\u00e7\u00e3o como um par\u00e2metro de outra fun\u00e7\u00e3o.</p> <pre><code>function executaFuncao(funcao) {\n    console.log('O resultado da fun\u00e7\u00e3o \u00e9:');\n    funcao();\n}\nexecutaFuncao(falaOie);   // O resultado da fun\u00e7\u00e3o \u00e9:\n                          // oie\n</code></pre>"},{"location":"fun%C3%A7%C3%B5es/function-declaration/#arrow-function","title":"Arrow function","text":"<p>\u00c9 a forma mais moderna de declararmos uma fun\u00e7\u00e3o</p> <pre><code>const funcArrow = () =&gt; {\n    console.log('sou uma arrow function');\n}\nfuncArrow();  // sou uma arrow function\n</code></pre> <p>Podemos atribuir uma fun\u00e7\u00e3o \u00e0 um parametro de um objeto</p> <pre><code>const pessoa = {\n    nome: 'Cesar',\n    // falar: () =&gt; console.log('e a\u00ed, tudo bem?'),  // com arrow\n    falar() { console.log('e a\u00ed, tudo bem?') },      // nova forma\n}\nconsole.log(pessoa.nome);  // Cesar\npessoa.falar();            // e a\u00ed, tudo bem?\n</code></pre>"},{"location":"fun%C3%A7%C3%B5es/generators/","title":"Generators","text":""},{"location":"fun%C3%A7%C3%B5es/generators/#definicao","title":"Defini\u00e7\u00e3o","text":"<p>Um generator \u00e9 uma fun\u00e7\u00e3o especial que permite pausar e retomar sua execu\u00e7\u00e3o.  Isso \u00e9 \u00fatil quando voc\u00ea precisa lidar com opera\u00e7\u00f5es demoradas ou iterar sobre  um grande conjunto de dados de forma eficiente. Os generators s\u00e3o criados  usando a fun\u00e7\u00e3o <code>function*</code>.</p> <p>Existe tamb\u00e9m sintaxe mais recente <code>async function*</code>, que introduz o  conceito de \"async generators\" para trabalhar com opera\u00e7\u00f5es ass\u00edncronas. Veremos isso no futuro.</p> <p>Generators s\u00e3o \u00fateis em v\u00e1rias situa\u00e7\u00f5es, como itera\u00e7\u00e3o pregui\u00e7osa sobre  grandes conjuntos de dados, lidar com c\u00f3digo ass\u00edncrono de forma mais leg\u00edvel  e criar pipelines de processamento de dados. Eles s\u00e3o uma caracter\u00edstica  poderosa do JavaScript que simplifica muitos aspectos do c\u00f3digo ass\u00edncrono e  da manipula\u00e7\u00e3o de sequ\u00eancias de dados.</p>"},{"location":"fun%C3%A7%C3%B5es/generators/#estrutura","title":"Estrutura","text":"<p>Para criar um generator, voc\u00ea usa a fun\u00e7\u00e3o <code>function*</code> e dentro dela, voc\u00ea  pode usar a instru\u00e7\u00e3o <code>yield</code>. O <code>yield</code> \u00e9 usado para pausar a execu\u00e7\u00e3o da  fun\u00e7\u00e3o e retornar um valor. Quando a fun\u00e7\u00e3o \u00e9 retomada, ela continua a partir  do ponto em que foi pausada, mantendo seu estado interno.</p> <pre><code>function* nomeDoGenerator() {\n    yield elementoGerado;\n}\n</code></pre> <p>A cada vez que chamamos o atributo <code>next</code> do generator, ele nos entrega um  elemento da itera\u00e7\u00e3o, como demonstrado abaixo: </p> <pre><code>{ value: 'elementoSendoEntregue', done: false }\n</code></pre> <p>Quando os elementos gerados chegam ao fim, o atributo <code>done</code> do objeto entregue  ser\u00e1 igual a <code>true</code> e o elemento entregue ser\u00e1 <code>undefined</code>.</p> <p>Caso usemos o <code>return</code>, ele encerrar\u00e1 o generator, excluindo qualquer <code>yield</code>  que venha ap\u00f3s ele.</p>"},{"location":"fun%C3%A7%C3%B5es/generators/#exemplos","title":"Exemplos","text":""},{"location":"fun%C3%A7%C3%B5es/generators/#basico","title":"B\u00e1sico","text":"<pre><code>function* myGenerator() {\n    yield 'elemento 1';\n    yield 'elemento 2';\n    yield 'elemento 3';\n    yield 'elemento 4';\n}\n\nconst gen1 = myGenerator();\nconsole.log(gen1);               // Object [Generator] {}\nconsole.log(gen1.next());        // { value: 'elemento 1', done: false }\nconsole.log(gen1.next().value);  // elemento 2\nconsole.log(gen1.next().value);  // elemento 3\nconsole.log(gen1.next().value);  // elemento 4\nconsole.log(gen1.next());        // { value: undefined, done: true }\n\n// iterando com for\nconst gen2 = myGenerator();\nfor (val of gen2) {\n    console.log(val);\n}\n</code></pre>"},{"location":"fun%C3%A7%C3%B5es/generators/#gerador-infinito","title":"Gerador infinito","text":"<pre><code>function* contador() {\n  let i = 0;\n  while (true) {\n    yield i;\n    i++;\n  }\n}\n\nconst gen = contador();\n\nconsole.log(gen.next().value); // 0\nconsole.log(gen.next().value); // 1\nconsole.log(gen.next().value); // 2\n</code></pre> <p>Neste exemplo, a fun\u00e7\u00e3o <code>contador</code> \u00e9 um generator que gera uma sequ\u00eancia  infinita de n\u00fameros inteiros come\u00e7ando por zero. O <code>yield</code> pausa a execu\u00e7\u00e3o da  fun\u00e7\u00e3o e retorna o valor atual de <code>i</code>, e o m\u00e9todo <code>next()</code> \u00e9 usado para  avan\u00e7ar para o pr\u00f3ximo valor da sequ\u00eancia.</p>"},{"location":"fun%C3%A7%C3%B5es/generators/#unindo-dois-geradores","title":"Unindo dois geradores","text":"<pre><code>function* generator1() {\n    yield 1;\n    yield 2;\n    yield 3;\n    yield 4;\n}\n\nfunction* generator2() {\n    yield* generator1();\n    yield 5;\n    yield 6;\n    yield 7;\n}\n\nlet gen4 = generator2()\nfor (val of gen4) {\n    console.log(val);  // itera de 1 \u00e0 7\n}\n</code></pre>"},{"location":"fun%C3%A7%C3%B5es/generators/#entregando-funcoes","title":"Entregando fun\u00e7\u00f5es","text":"<pre><code>function* getFunction() {\n    yield function () {\n        console.log('vim do 1. yield');\n    }\n    yield function () {\n        console.log('vim do 2. yield');\n    }\n    return function () {\n        console.log('vim do return');\n    }\n}\n\nlet gen5 = getFunction();\n\nconst func1 = gen5.next().value;\nconst func2 = gen5.next().value;\nconst func3 = gen5.next().value;\n\nfunc1();  // vim do 1. yield\nfunc2();  // vim do 2. yield\nfunc3();  // vim do return\n</code></pre>"},{"location":"fun%C3%A7%C3%B5es/parameters/","title":"Parametros","text":"<p>Os par\u00e2metros de fun\u00e7\u00e3o s\u00e3o os valores que podemos passar para uma fun\u00e7\u00e3o  quando a chamamos. Os par\u00e2metros permitem que forne\u00e7amos dados de entrada para  uma fun\u00e7\u00e3o, que a fun\u00e7\u00e3o pode ent\u00e3o usar em seu corpo para executar uma tarefa  espec\u00edfica. Os par\u00e2metros s\u00e3o definidos na declara\u00e7\u00e3o de fun\u00e7\u00e3o e atuam como  vari\u00e1veis locais dentro do escopo da fun\u00e7\u00e3o.</p> <pre><code>function soma(a, b) {\n    return a + b;\n}\n\nsoma(10, 45);  // 55\n</code></pre>"},{"location":"fun%C3%A7%C3%B5es/parameters/#arguments","title":"Arguments","text":"<p>No JavaScript, quando n\u00e3o declaramos os argumentos necess\u00e1rios numa fun\u00e7\u00e3o, mas  vamos invoc\u00e1-la passando algum argumento, o JavaScript n\u00e3o causa erros, pois armazena todos estes argumentos numa vari\u00e1vel especial chamada: <code>arguments</code></p> <pre><code>function getArgs() {\n    console.log(arguments);\n}\n\ngetArgs('cavalo', 'lambreta', 123, 45);  // [Arguments] { '0': 'cavalo', '1': 'lambreta', '2': 123, '3': 45 }\n\nfunction getArgs2(a, b) {\n    console.log(a, b, arguments);\n}\n\ngetArgs2('\u00c9gua', 'moto', 12);  // \u00c9gua moto [Arguments] { '0': '\u00c9gua', '1': 'moto', '2': 12 }\n</code></pre> <p>Embora n\u00e3o tenhamos 'arguments' em arrow functions, podemos usar o  <code>spread operator</code> para trabalhar da mesma forma.</p> <pre><code>const myNumbers = (...args) =&gt; {\n    console.log(args);\n}\nmyNumbers(1, 2, 3, 4, 5, 6, 7, 8);  // [1, 2, 3, 4, 5, 6, 7, 8]\n</code></pre>"},{"location":"fun%C3%A7%C3%B5es/parameters/#valor-padrao","title":"Valor padr\u00e3o","text":"<p>Tamb\u00e9m podemos pr\u00e9-determinar o valor padr\u00e3o de algum par\u00e2metro, assim, caso  no at\u00f3 de invocar uma fun\u00e7\u00e3o, nenhum valor seja passado ao par\u00e2metro, a fun\u00e7\u00e3o vai assumir o valor padr\u00e3o.</p> <pre><code>function multiplica(a, b = 1, c = 21) {\n    return a * b + c;\n}\n\nconsole.log(multiplica(23, 12, 4));         // 280\nconsole.log(multiplica(27));                // 48\nconsole.log(multiplica(3, 3));              // 30\nconsole.log(multiplica(4, undefined, 16));  // 20\n</code></pre>"},{"location":"fun%C3%A7%C3%B5es/parameters/#destructuring","title":"Destructuring","text":"<p>Destructuring \u00e9 uma forma de extrair valores de objetos ou arrays e atribu\u00ed-los  a vari\u00e1veis de forma mais concisa. Isso pode tornar o c\u00f3digo mais leg\u00edvel e  facilitar a manipula\u00e7\u00e3o de dados. </p> <pre><code>function gessNumbers([num1, num2, num3]) {\n    console.log(num1, num2, num3);\n}\n\ngessNumbers([134, 475, 65]);  // 134 475 65\n\nfunction fullName({ name, lastname }) {\n    console.log(name, lastname);\n}\n\nfullName({ name: 'Cesar', lastname: 'Godoi' });  // Cesar Godoi\n</code></pre>"},{"location":"fun%C3%A7%C3%B5es/parameters/#exemplo","title":"Exemplo","text":"<p>Considere a seguinte fun\u00e7\u00e3o que recebe como primeiro artumento um operador  e uma lista de n\u00fameros que devem ser processados de acordo com o  operador.</p> <pre><code>function calc(oper, ...numbers) {\n    if (oper === '+') {\n        let sum = 0;\n        numbers.forEach((num) =&gt; sum += num);\n        return sum;\n    }\n    if (oper === '-') {\n        let sub = Math.max(...numbers);\n        numbers = numbers.filter((num) =&gt; num !== sub);\n        numbers.forEach((num) =&gt; sub -= num);\n        return sub\n    }\n    if (oper === '*') {\n        let mult = 1;\n        numbers.forEach((num) =&gt; mult *= num);\n        return mult;\n    }\n    if (oper === '/') {\n        let div = numbers.shift();\n        numbers.forEach((num) =&gt; div /= num);\n        return div;\n    }\n}\nconsole.log(calc('+', 1, 2, 3, 4));  // 10\nconsole.log(calc('-', 12, 3, 34));  // 19\nconsole.log(calc('*', 2, 3, 4, 5));  // 120\nconsole.log(calc('/', 20, 2, 4));  // 2.5\n</code></pre>"},{"location":"fun%C3%A7%C3%B5es/resursive-function/","title":"Fun\u00e7\u00f5es recursivas","text":"<p>\u00c9 uma fun\u00e7\u00e3o que chama a si mesma para realizar uma tarefa. Em termos mais  simples, \u00e9 um conceito onde uma fun\u00e7\u00e3o \u00e9 definida em termos de si mesma. Isso  \u00e9 comum em programa\u00e7\u00e3o, pois permite a implementa\u00e7\u00e3o de algoritmos complexos  de forma mais elegante e concisa.</p> <p>Aqui est\u00e1 um exemplo simples de uma fun\u00e7\u00e3o recursiva em JavaScript que calcula  o fatorial de um n\u00famero:</p> <pre><code>function fatorial(n) {\n  if (n &gt; 10) return;  // \u00e9 importande determinar quando ocorrer\u00e1 a sa\u00edda\n  if (n === 0) {\n    return 1;\n  } else {\n    return n * fatorial(n - 1);\n  }\n}\n\nconsole.log(fatorial(5));  // 120\n</code></pre> <p>Neste exemplo, a fun\u00e7\u00e3o <code>fatorial</code> \u00e9 definida em termos de si mesma, onde ela  calcula o fatorial de um n\u00famero <code>n</code> multiplicando <code>n</code> pelo fatorial de <code>n - 1</code>.  A recurs\u00e3o continua at\u00e9 que <code>n</code> seja igual a zero, momento em que a fun\u00e7\u00e3o  retorna 1 (o caso base). Essa fun\u00e7\u00e3o recursiva \u00e9 uma implementa\u00e7\u00e3o cl\u00e1ssica de  como calcular o fatorial de um n\u00famero.</p> <p>No entanto, \u00e9 importante ter cuidado ao usar fun\u00e7\u00f5es recursivas, pois elas  podem levar a estouro de pilha (stack overflow) se n\u00e3o houver um caso base  adequado ou se a recurs\u00e3o for muito profunda. Certifique-se sempre de definir  um caso base e garantir que a recurs\u00e3o tenha uma condi\u00e7\u00e3o de parada para  evitar problemas de desempenho.</p>"}]}